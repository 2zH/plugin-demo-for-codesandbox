import { curry, compose, deepMerge } from '@pluginjs/utils';
import Component from '@pluginjs/component';
import { addClass } from '@pluginjs/classes';
import { bindEvent, removeEvent } from '@pluginjs/events';
import { eventable, register, stateable, styleable } from '@pluginjs/pluginjs';

const namespace = 'inputMask';

const events = {
  READY: 'ready',
  ENABLE: 'enable',
  DISABLE: 'disable',
  DESTROY: 'destroy',
  FOCUS: 'focus',
  BLUR: 'blur'
};

const classes = {
  NAMESPACE: `pj-${namespace}`,
  INPUT: '{namespace}-input'
};

const methods = ['enable', 'disable', 'destroy'];

const defaults = {
  type: 'custom',
  delimiter: '',
  blocks: 'noLimit'
};

const info = { version: '0.0.1' };

let Model = class Model {
  constructor(data) {
    this.__value = data;
  }
  // value1 -> func -> func -> value2
  static of(data) {
    return new Model(data);
  }

  isNothing() {
    return !this.__value;
  }

  join() {
    return this.isNothing() ? '' : this.__value;
  }

  map(f) {
    return Model.of(f(this.__value));
  }

  chain(f) {
    return this.map(f).join();
  }
};

const map = curry((f, functor) => functor.map(f));

const chain = curry((f, monad) => monad.chain(f));

const reduce = curry((f, v) => v.reduce(f));

const getRange = curry((blocks, index) => {
  if (!index) {
    return [0, blocks[index]];
  }

  const min = index >= 2 ? blocks.filter((v, i) => i < index).reduce((a, b) => a + b) : blocks[index - 1];

  const max = blocks.filter((v, i) => i <= index).reduce((a, b) => a + b);
  return [min, max];
});

const sum = (a, b) => a + b;

const computeLens = compose(map(reduce(sum)), Model.of);

// baseFormat :: config => String
const baseFormat = curry(({ blocks, delimiter }, data) => {
  const range = getRange(blocks);
  const blockLens = computeLens(blocks).join();
  return blocks.map((v, k) => data.slice(...range(k))).filter(Boolean).join(delimiter).concat(data.slice(blockLens));
});

const timeFormat = formattedData => `${formattedData.slice(0, 5)} ${formattedData.slice(5)}`;

const lensLimit = curry((length, data) => {
  if (data.length > length) {
    return data.slice(0, length);
  }
  return data;
});

const isNumber = data => {
  const result = !isNaN(Number(data.slice(-1)));
  return result;
};

const getNumberByStrRange = curry((data, min, max) => {
  if (data.length > min + 1) {
    return Number(data.slice(min, max));
  }
  return Number(`${data[min]}0`);
});

const dateLimit = data => {
  const backspace = data.slice(0, -1);
  const range = getNumberByStrRange(data);
  const mm = range(4, 6);
  const dd = range(6, 8);
  // check isNumber
  if (!isNumber(data)) {
    return backspace;
  }

  // check mm
  if (mm && mm > 12) {
    return backspace;
  }

  // check dd
  if (dd && dd > 31) {
    return backspace;
  }

  return data;
};

const timeLimit = curry((hourFormat, data) => {
  const type = ['AM', 'PM'];
  const time = data.slice(0, 4);
  const range = getNumberByStrRange(time);
  const min = range(0, 2);
  const sec = range(2, 4);
  const is12Hour = hourFormat === '12';
  const backspace = data.slice(0, -1);

  // check isNumber
  if (!isNumber(time)) {
    return backspace;
  }

  if (sec && sec > 60) {
    return backspace;
  }

  if (!is12Hour) {
    if (min > 24) {
      return backspace;
    }
    return data;
  }

  if (min > 12) {
    return backspace;
  }

  const unit = data.slice(4).toUpperCase();

  // check string limit
  if (unit.length === 1 && type.map(v => v[0]).find(v => v === unit)) {
    return time + unit;
  }

  if (unit.length === 2) {
    if (type.find(v => v === unit)) {
      return time + unit;
    }
    return time + unit[0];
  }

  return time;
});

var _dec, _dec2, _dec3, _dec4, _class;

let InputMask = (_dec = eventable(events), _dec2 = styleable(classes), _dec3 = stateable(), _dec4 = register(namespace, {
  defaults: defaults,
  methods: methods
}, info), _dec(_class = _dec2(_class = _dec3(_class = _dec4(_class = class InputMask extends Component {
  constructor(element, options = {}) {
    super(namespace, element);
    this.options = deepMerge(defaults, options, this.getDataOptions());
    this.initClasses(classes);
    addClass(this.classes.INPUT, this.element);
    this.data = '';
    this.initStates();
    this.initialize();
  }

  initialize() {
    this.bind();
    this.lastValue = '';
    const options = this.match(this.options.type);

    const input = newData => {
      if (this.data.length && this._hasBackspace) {
        this._hasBackspace = false;
        return Model.of(this.data.slice(0, -1));
      }
      return Model.of(this.data + newData);
    };

    const updateMiddleware = options => {
      const { type, blocks } = options;
      const lens = computeLens(blocks).join();
      switch (type) {
        case 'time':
          {
            const { format } = options;
            const timeLens = format === '12' ? lens + 2 : lens;
            return compose(timeLimit(format), lensLimit(timeLens));
          }
        case 'date':
          {
            return compose(dateLimit, lensLimit(lens));
          }
        default:
          {
            return lensLimit(lens);
          }
      }
    };

    const formatMiddleware = options => {
      const { type } = options;
      switch (type) {
        case 'time':
          {
            return compose(timeFormat, baseFormat(options));
          }
        default:
          {
            return baseFormat(options);
          }
      }
    };

    // update :: String -> monad
    const update = compose(chain(updateMiddleware(options)), input);

    // getFormattedData :: {} -> String
    const format = compose(chain(formatMiddleware(options)), Model.of);
    this.onChange = event => {
      const data = event.target.value.slice(this.lastValue.length);
      this.data = update(data);
      this.element.value = format(this.data);
    };
    this.observe();
    this.enter('initialized');
    this.trigger(events.READY);
  }

  observe() {
    const getLastValue = e => {
      const keyCode = e.keyCode || e.which;
      if (keyCode === 8) {
        this._hasBackspace = true;
      }
      this.lastValue = e.target.value;
    };
    compose(bindEvent({ type: 'keydown', handler: getLastValue }), bindEvent({ type: 'input', handler: this.onChange }))(this.element);
    // this.element.addEventListener('keydown', getLastValue, false)
    // this.element.addEventListener('input', this.onChange, false)
    this.hasObserve = true;
  }

  unObserve() {
    if (this.hasObserve) {
      removeEvent('input', this.element);
      // this.element.removeEventListener('input', this.onChange, false)
      this.hasObserve = false;
    }
  }

  match(type) {
    switch (type) {
      default:
        {
          return {
            type,
            blocks: this.options.blocks,
            delimiter: this.options.delimiter
          };
        }
      case 'time':
        {
          return {
            type,
            delimiter: ':',
            blocks: [2, 2],
            format: this.options.hours
          };
        }
      case 'card':
        {
          return {
            type,
            delimiter: ' ',
            blocks: [4, 4, 4, 4]
          };
        }
      case 'date':
        {
          return {
            type,
            delimiter: '/',
            blocks: [4, 2, 2]
          };
        }
    }
  }

  bind() {
    compose(...[{ type: this.eventName('touch'), handler: () => false }, { type: this.eventName('click'), handler: () => false }, {
      type: this.eventName('focus.keyboard'),
      handler: () => this.trigger(events.FOCUS)
    }, {
      type: this.eventName('blur.keyboard'),
      handler: () => this.trigger(events.BLUR)
    }].map(options => bindEvent(options)))(this.element);
  }

  unbind() {
    removeEvent(this.eventName());
    this.unObserve();
  }

  enable() {
    if (this.is('disabled')) {
      this.leave('disabled');
    }
    this.trigger(events.ENABLE);
  }

  disable() {
    if (!this.is('disabled')) {
      this.enter('disabled');
    }

    this.trigger(events.DISABLE);
  }

  destroy() {
    if (this.is('initialized')) {
      this.unbind();

      this.leave('initialized');
    }
    this.trigger(events.DESTROY);
    super.destroy();
  }
}) || _class) || _class) || _class) || _class);

export default InputMask;
