(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global['@pluginjs/i18n'] = {})));
}(this, (function (exports) { 'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var defineProperty = function (obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  };

  var slicedToArray = function () {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();

  var _extends$1 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  function nub(arr) {
    return Array.from(new Set(arr));
  }
  function isPlainObject(data) {
    if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object') {
      return false;
    }

    if (data === null) {
      return false;
    }

    if (data instanceof Set || data instanceof Map) {
      return false;
    }

    if (Array.isArray(data)) {
      return false;
    }

    return true;
  }
  function deepMergeTwo(x, y) {
    if (isPlainObject(y) && isPlainObject(x) || isPlainObject(x) && Array.isArray(y)) {
      return fromPairs$1(nub(Object.keys(x).concat(Object.keys(y))).map(function (key) {
        return [key, deepMergeTwo(x[key], y[key])];
      }));
    }

    if (isPlainObject(y) && typeof x === 'function') {
      return Object.assign(function () {
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return x.apply(this, args);
      }, y);
    }

    if (isPlainObject(y) && Array.isArray(x)) {
      return Object.assign([], x, y);
    }

    if (isPlainObject(x) && typeof y === 'function') {
      return Object.assign(function () {
        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        return y.apply(this, args);
      }, x);
    }

    if (Array.isArray(y) && Array.isArray(x)) {
      // return x.concat(y)
      return nub(Object.keys(y).concat(Object.keys(x))).map(function (index) {
        return deepMergeTwo(x[index], y[index]);
      });
    }

    if (typeof y === 'undefined') {
      return x;
    }
    return y;
  }
  function isObject(obj) {
    return Object(obj) === obj;
  }
  function deepMerge() {
    for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    return args.filter(isObject).reduce(deepMergeTwo);
  }

  /* Credit to https://github.com/jonschlinkert/get-value MIT */
  function getValueByPath(obj, path) {
    if (Object(obj) !== obj || typeof path === 'undefined') {
      return obj;
    }

    if (path in obj) {
      return obj[path];
    }

    var segs = path.split('.');
    var length = segs.length;
    if (!length) {
      return undefined;
    }
    var i = -1;

    while (obj && ++i < length) {
      var key = segs[i];
      while (key[key.length - 1] === '\\') {
        key = key.slice(0, -1) + '.' + segs[++i];
      }
      obj = obj[key];
    }
    return obj;
  }

  function fromPairs$1(arr) {
    return arr.reduce(function (r, _ref10) {
      var _ref11 = slicedToArray(_ref10, 2),
          k = _ref11[0],
          v = _ref11[1];

      return _extends$1({}, r, defineProperty({}, k, v));
    }, {});
  }

  /* Credit to https://github.com/jonschlinkert/get-value MIT */
  function getValueByPath$1(obj, path) {
    if (Object(obj) !== obj || typeof path === 'undefined') {
      return obj;
    }

    if (path in obj) {
      return obj[path];
    }

    var segs = path.split('.');
    var length = segs.length;
    if (!length) {
      return undefined;
    }
    var i = -1;

    while (obj && ++i < length) {
      var key = segs[i];
      while (key[key.length - 1] === '\\') {
        key = key.slice(0, -1) + '.' + segs[++i];
      }
      obj = obj[key];
    }
    return obj;
  }

  /* Credit to https://github.com/Matt-Esch/string-template MIT */
  var template = function () {
    var pattern = /\{\s*([.0-9a-zA-Z_]+)\s*\}/g;

    function render(string) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      if (args.length === 1 && _typeof(args[0]) === 'object') {
        args = args[0];
      }

      if (!args || !args.hasOwnProperty) {
        args = {};
      }

      return string.replace(pattern, function (match, i, index) {
        var result = null;

        if (string[index - 1] === '{' && string[index + match.length] === '}') {
          return i;
        }

        if (args.hasOwnProperty(i)) {
          result = args[i];
        } else if (i.indexOf('.') !== -1) {
          result = getValueByPath$1(args, i);
        }

        if (result === null || result === undefined) {
          return '';
        }

        return result;
      });
    }

    return {
      render: render,
      compile: function compile(str) {
        return function () {
          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          return render.apply(undefined, [str].concat(args));
        };
      },
      parse: function parse(str) {
        var matches = str.match(pattern);

        if (matches === null) {
          return false;
        }

        var parsed = [];
        for (var i = 0; i < matches.length; i++) {
          if (!matches[i].match(/^\{\{.+\}\}$/g)) {
            parsed.push(matches[i].substring(1, matches[i].length - 1).trim());
          }
        }

        return parsed;
      }
    };
  }();

  var I18N = function () {
    function I18N(defaults$$1, translations) {
      classCallCheck(this, I18N);

      this.defaults = deepMerge(I18N.defaults, defaults$$1);
      this.translations = translations ? translations : {};
    }

    createClass(I18N, [{
      key: 'hasTranslation',
      value: function hasTranslation(locale) {
        return locale in this.translations;
      }
    }, {
      key: 'addTranslation',
      value: function addTranslation(locale, translation) {
        if (this.translations[locale]) {
          Object.assign(this.translations[locale], translation);
        } else {
          this.translations[locale] = translation;
        }
      }
    }, {
      key: 'getTranslation',
      value: function getTranslation(locale) {
        if (this.translations[locale]) {
          return this.translations[locale];
        }
        return {};
      }
    }, {
      key: 'instance',
      value: function instance() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var that = this;

        var _options = deepMerge(that.defaults, options);
        var _locale = _options.locale;
        function getMessage(key, locale) {
          var translation = that.getTranslation(locale);
          var message = getValueByPath(translation, key);

          return message;
        }

        return {
          translate: function translate(key) {
            var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var locale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _locale;

            var message = getMessage(key, locale);
            if (message === undefined && _options.fallbacks) {
              var locales = locale.split('-');
              if (locales.length > 1 && that.hasTranslation(locales[0])) {
                message = getMessage(key, locales[0]);
              }

              if (message === undefined) {
                var fallbackLocale = void 0;
                if (_options.fallbacks !== true && that.hasTranslation(_options.fallbacks)) {
                  fallbackLocale = _options.fallbacks;
                } else {
                  fallbackLocale = that.defaults.locale;
                }

                message = getMessage(key, fallbackLocale);
              }
            }

            if (Object.prototype.toString.call(message) === '[object Array]' && message.length >= 2) {
              if (typeof args._number === 'string') {
                if (typeof args[args._number] !== 'undefined') {
                  var _number = parseInt(args[args._number], 10);

                  if (_number === 1) {
                    message = message[0];
                  } else if (_number > 1) {
                    message = message[1];
                  } else if (_number === 0 && message.length >= 3) {
                    message = message[2];
                  }
                }
              }
            }

            if (typeof message === 'string') {
              var parsed = template.parse(message);
              if (!parsed) {
                return message;
              }
              var _key = void 0;
              for (var i = 0; i < parsed.length; i++) {
                _key = parsed[i];
                if (typeof args[_key] === 'undefined') {
                  args[_key] = _options.missingPlaceholder(_key);
                } else if (args[_key] === null) {
                  args[_key] = _options.nullPlaceholder(_key);
                }
              }
              return template.render(message, args);
            }

            if (Object(message) === message) {
              return message;
            }

            return '[missing "' + locale + '.' + key + '" translation]';
          },
          setLocale: function setLocale(locale) {
            _locale = locale;
          },
          getLocale: function getLocale() {
            return _locale;
          }
        };
      }
    }, {
      key: 'setTranslations',
      value: function setTranslations(translations) {
        this.translations = translations;
      }
    }]);
    return I18N;
  }();

  I18N.defaults = {
    locale: 'en',
    fallbacks: true,
    nullPlaceholder: function nullPlaceholder(key) {
      return '[missing {{' + key + '}} value]';
    },
    missingPlaceholder: function missingPlaceholder(key) {
      return '[missing {{' + key + '}} value]';
    }
  };

  exports.default = I18N;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
