var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

function fromPairs(arr) {
  return arr.reduce((r, [k, v]) => _extends({}, r, {
    [k]: v
  }), {});
}

function mergeWith(...args) {
  const objs = args.slice(0, -1);
  const customizer = args[args.length - 1];
  return Object.entries(args[0]).reduce((r, [k]) => _extends({}, r, {
    [k]: objs.map(obj => obj[k]).filter(v => Boolean(v) || v === 0).reduce((r, i) => customizer(r, i))
  }), {});
}

const T = {
  0: 'X',
  1: 'Y',
  2: 'Z'
};

function mapTransformToAnime(str) {
  const css3dList = ['translate', 'rotate', 'scale'];
  return css3dList.filter(key => {
    const regx = new RegExp(key, 'g');
    if (str.match(regx)) {
      return true;
    }
    return false;
  }).reduce((initialState, key) => {
    const matrix = str.match(/\(([^()]+)\)/)[1].split(',');
    const map = mapMatch(key);
    return map(matrix);
  }, {});
}

function mapMatch(type) {
  switch (type) {
    case 'translate':
      return mapToTranslate;
    case 'rotate':
      return mapToRotate;
    case 'scale':
      return mapToScale;
    default:
      return () => 'no match!';
  }
}

function mapToScale(matrix) {
  // console.group('scale')
  const result = matrix.map((value, index) => {
    const n = parseFloat(value, 10);
    const result = { [`scale${T[index]}`]: n || 0
      // console.log(result)
    };return result;
  });
  return result.reduce(mergeObject);
}

function mapToTranslate(matrix) {
  const result = matrix.map((value, index) => {
    const n = parseFloat(value.slice(0, -2), 10);
    const result = { [`translate${T[index]}`]: n || 0 };
    return result;
  });
  return result.reduce(mergeObject);
}

function mapToRotate(matrix) {
  const value = matrix[matrix.length - 1].slice(0, -3);
  const transformType = matrix.slice(0, -1).map((n, index) => {
    if (parseInt(n, 10)) {
      return `rotate${T[index]}`;
    }
    return n;
  }).filter(isNotEmpty);
  return { [transformType[0]]: parseFloat(value) };
}

function mergeObject(r, i) {
  return _extends({}, r, i);
}

function customizer(objValue, srcValue) {
  if (Array.isArray(objValue)) {
    return objValue.concat(srcValue);
  }
  return [objValue, srcValue];
}

function isNotEmpty(value) {
  if (value) {
    return true;
  }
  return false;
}

function filterOffset(obj) {
  const result = objectWithoutProperties(obj, ['offset']);
  return result;
}

function filterEmptyValues(obj) {
  return fromPairs(Object.entries(obj).filter(([, v]) => {
    const arr = v.filter(i => Boolean(i));
    if (arr.length) {
      return true;
    }
    return false;
  }).map(([k, v]) => {
    const value = v.map(i => {
      if (i === undefined) {
        if (/scale/g.test(k)) {
          return 1;
        }
        return 0;
      }
      return i;
    });
    return [k, value];
  }));
}

function mapKeyFramesToAnime(keyframes) {
  const transformNoneIndex = [];
  const transformKeys = new Set();
  const newKeyFrames = keyframes.map((keyframe, keyframeIndex) => {
    const { transform } = keyframe,
          newKeyFrame = objectWithoutProperties(keyframe, ['transform']);
    if (transform) {
      const arr = transform.split(') ').map((item, index, arr) => {
        if (index !== arr.length - 1) {
          return `${item})`;
        }
        return item;
      }).map(value => {
        if (/3d/g.test(value)) {
          const transformObject = mapTransformToAnime(value);
          Object.keys(transformObject).map(key => transformKeys.add(key));
          return transformObject;
        }
        return value;
      }).filter(value => typeof value !== 'string');
      // console.log(arr)
      if (!arr.length) {
        transformNoneIndex.push(keyframeIndex);
        return newKeyFrame;
      }
      return Object.assign({}, newKeyFrame, ...arr);
    }
    return newKeyFrame;
  });
  const emptyTransform = fromPairs(Array.from(transformKeys).map(key => {
    if (/scale/g.test(key)) {
      return [key, 1];
    }
    return [key, 0];
  }));
  if (transformNoneIndex.length) {
    for (const index of transformNoneIndex) {
      Object.assign(newKeyFrames[index], emptyTransform);
    }
  }
  const data = mergeWith(...newKeyFrames, customizer);
  const result = filterOffset(filterEmptyValues(data));
  return result;
}

const deepClone = obj => {
  if (typeof obj === 'function') {
    return obj;
  }
  return JSON.parse(JSON.stringify(obj));
};
function nub(arr) {
  return Array.from(new Set(arr));
}
function isPlainObject(data) {
  if (typeof data !== 'object') {
    return false;
  }

  if (data === null) {
    return false;
  }

  if (data instanceof Set || data instanceof Map) {
    return false;
  }

  if (Array.isArray(data)) {
    return false;
  }

  return true;
}
function deepMergeTwo(x, y) {
  if (isPlainObject(y) && isPlainObject(x) || isPlainObject(x) && Array.isArray(y)) {
    return fromPairs$1(nub(Object.keys(x).concat(Object.keys(y))).map(key => [key, deepMergeTwo(x[key], y[key])]));
  }

  if (isPlainObject(y) && typeof x === 'function') {
    return Object.assign(function (...args) {
      return x.apply(this, args);
    }, y);
  }

  if (isPlainObject(y) && Array.isArray(x)) {
    return Object.assign([], x, y);
  }

  if (isPlainObject(x) && typeof y === 'function') {
    return Object.assign(function (...args) {
      return y.apply(this, args);
    }, x);
  }

  if (Array.isArray(y) && Array.isArray(x)) {
    // return x.concat(y)
    return nub(Object.keys(y).concat(Object.keys(x))).map(index => deepMergeTwo(x[index], y[index]));
  }

  if (typeof y === 'undefined') {
    return x;
  }
  return y;
}
function isObject(obj) {
  return Object(obj) === obj;
}
function deepMerge(...args) {
  return args.filter(isObject).reduce(deepMergeTwo);
}

const curry = (fn, args = []) => (...subArgs) => {
  const currylen = fn.currylen || fn.length;
  const collect = args.concat(subArgs);
  if (collect.length >= currylen) {
    return fn(...collect);
  }
  return curry(fn, collect);
};

const compose = (...fn) => {
  const callback = (...args) => fn.reduceRight((r, i, index) => {
    if (Array.isArray(r) && index === fn.length - 1) {
      return i(...r);
    }
    return i(r);
  }, args);
  callback.currylen = fn[fn.curylen || fn.length - 1].length;
  return callback;
};

const MAX_UID = 1000000;

function getUID(prefix) {
  do {
    // eslint-disable-next-line no-bitwise
    prefix += ~~(Math.random() * MAX_UID); // "~~" acts like a faster Math.floor() here
  } while (document.getElementById(prefix));
  return prefix;
}

function range(v) {
  return Array.from({ length: v }, (v, i) => i);
}

function reflow(element) {
  return element.offsetHeight;
}

function arraysEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (a === undefined || b === undefined) {
    return false;
  }
  if (a.length !== b.length) {
    return false;
  }

  for (let i = 0; i < a.length; ++i) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}

function arrayDiff(a, b) {
  // let t;
  // if (a.length < b.length) {
  //   t = b;
  //   b = a;
  //   a = t;
  // }
  return a.filter(n => b.indexOf(n) < 0);
}

function arrayIntersect(a, b) {
  let t;
  if (b.length > a.length) {
    t = b;
    b = a;
    a = t;
  }
  return a.filter(n => b.indexOf(n) !== -1);
}

function convertPercentageToFloat(n) {
  return parseFloat(n.slice(0, -1) / 100, 10);
}

function convertFloatToPercentage(n) {
  if (n < 0) {
    n = 0;
  } else if (n > 1) {
    n = 1;
  }
  return `${parseFloat(n).toFixed(4) * 100}%`;
}

function convertMatrixToArray(value) {
  if (value && value.substr(0, 6) === 'matrix') {
    return value.replace(/^.*\((.*)\)$/g, '$1').replace(/px/g, '').split(/, +/);
  }
  return false;
}

function getTime() {
  if (typeof window.performance !== 'undefined' && window.performance.now) {
    return window.performance.now();
  }
  return Date.now();
}

function camelize(word, first = true) {
  word = word.replace(/[_.-\s](\w|$)/g, (_, x) => x.toUpperCase());

  if (first) {
    word = word.substring(0, 1).toUpperCase() + word.substring(1);
  }
  return word;
}

/* Credit to https://github.com/jonschlinkert/get-value MIT */
function getValueByPath(obj, path) {
  if (Object(obj) !== obj || typeof path === 'undefined') {
    return obj;
  }

  if (path in obj) {
    return obj[path];
  }

  const segs = path.split('.');
  const length = segs.length;
  if (!length) {
    return undefined;
  }
  let i = -1;

  while (obj && ++i < length) {
    let key = segs[i];
    while (key[key.length - 1] === '\\') {
      key = `${key.slice(0, -1)}.${segs[++i]}`;
    }
    obj = obj[key];
  }
  return obj;
}

/* Throttle execution of a function.
 * Especially useful for rate limiting execution of
 * handlers on events like resize and scroll. */
function throttle(func, delay) {
  let running = false;
  function resetRunning() {
    running = false;
  }

  if (delay !== undefined || delay !== null) {
    return (...args) => {
      const that = this;

      if (running) {
        return;
      }
      running = true;
      func.apply(that, args);
      window.setTimeout(resetRunning, delay);
    };
  }

  return (...args) => {
    const that = this;

    if (running) {
      return;
    }
    running = true;
    window.requestAnimationFrame(() => {
      func.apply(that, args);
      resetRunning();
    });
  };
}

/* Debounce execution of a function.
 * Debouncing, unlike throttling, guarantees that a function
 * is only executed a single time at the very end. */
function debounce(func, delay = 100) {
  let timer;

  return (...args) => {
    const that = this;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    timer = setTimeout(() => {
      func.apply(that, args);
    }, delay);
  };
}

function fromPairs$1(arr) {
  return arr.reduce((r, [k, v]) => _extends({}, r, {
    [k]: v
  }), {});
}
function mergeWith$1(obj1, obj2, customizer) {
  return Object.entries(obj1).reduce((r, [k, v]) => _extends({}, r, {
    [k]: customizer(v, obj2[k])
  }), {});
}

export { deepClone, nub, isPlainObject, deepMerge, curry, compose, getUID, range, reflow, arraysEqual, arrayDiff, arrayIntersect, convertPercentageToFloat, convertFloatToPercentage, convertMatrixToArray, getTime, camelize, getValueByPath, throttle, debounce, fromPairs$1 as fromPairs, mergeWith$1 as mergeWith, mapKeyFramesToAnime as keyframes2Anime };
