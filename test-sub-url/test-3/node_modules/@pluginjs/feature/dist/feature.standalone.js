(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global['@pluginjs/feature'] = {})));
}(this, (function (exports) { 'use strict';

  /* eslint no-undef: "off" */

  /* Credit to http://featurejs.com MIT */
  /**
   * Test if it's an old device that we want to filter out
   */
  var old = function old() {
    return Boolean(/(Android\s(1.|2.))|(Silk\/1.)/i.test(navigator.userAgent));
  };

  /**
   * Function that takes a standard CSS property name as a parameter and
   * returns it's prefixed version valid for current browser it runs in
   */
  var pfx = function () {
    var prefixes = ['Webkit', 'Moz', 'O', 'ms'];
    var memory = {};
    var style = document.createElement('dummy').style;
    return function (prop) {
      if (typeof memory[prop] === 'undefined') {
        var ucProp = prop.charAt(0).toUpperCase() + prop.substr(1);
        var props = (prop + ' ' + prefixes.join(ucProp + ' ') + ucProp).split(' ');
        memory[prop] = null;

        for (var i in props) {
          if (style[props[i]] !== undefined) {
            memory[prop] = props[i];
            break;
          }
        }
      }
      return memory[prop];
    };
  }();

  function prefixedProperty(property) {
    return pfx(property);
  }

  var transitionProperty = function transitionProperty() {
    return pfx('transition');
  };

  var transformProperty = function transformProperty() {
    return pfx('transform');
  };

  var animationProperty = function animationProperty() {
    return pfx('animation');
  };

  var transitionEndEvent = function transitionEndEvent() {
    var eventNames = {
      transition: 'transitionend',
      OTransition: 'oTransitionEnd',
      MozTransition: 'transitionend',
      WebkitTransition: 'webkitTransitionEnd'
    };
    var style = document.createElement('dummy').style;
    for (var i in eventNames) {
      if (eventNames.hasOwnProperty(i)) {
        if (style[i] !== undefined) {
          return eventNames[i];
        }
      }
    }
    return false;
  };

  var animationEndEvent = function animationEndEvent() {
    var eventNames = {
      animation: 'animationend',
      OAnimation: 'oanimationend',
      msAnimation: 'MSAnimationEnd',
      MozAnimation: 'animationend',
      WebkitAnimation: 'webkitAnimationEnd'
      // const style = document.body.style
    };var style = {};
    for (var i in eventNames) {
      if (eventNames.hasOwnProperty(i)) {
        if (style[i] !== undefined) {
          return eventNames[i];
        }
      }
    }
    return false;
  };

  // Test if CSS 3D transforms are supported
  var transform3D = function transform3D() {
    var test = !old() && pfx('perspective') !== null;
    return Boolean(test);
  };

  // Test if CSS transforms are supported
  var transform = function transform() {
    var test = !old() && pfx('transformOrigin') !== null;
    return Boolean(test);
  };

  // Test if CSS transitions are supported
  var transition = function transition() {
    var test = pfx('transition') !== null;
    return Boolean(test);
  };

  // Test if CSS sticky  are supported

  var canSticky = function canSticky() {
    var _canSticky = false;
    var documentFragment = document.documentElement;
    var testElement = document.createElement('div');
    documentFragment.appendChild(testElement);
    var prefixedSticky = ['sticky', '-webkit-sticky'];

    for (var i = 0; i < prefixedSticky.length; i++) {
      testElement.style.position = prefixedSticky[i];
      _canSticky = Boolean(window.getComputedStyle(testElement).position.match('sticky'));
      if (_canSticky) {
        break;
      }
    }
    documentFragment.removeChild(testElement);

    return _canSticky;
  };

  // Test if SVG is supported
  var isSupportedSvg = function isSupportedSvg() {
    return Boolean(document.createElementNS) && Boolean(document.createElementNS('http://www.w3.org/2000/svg', 'svg').createSVGRect);
  };

  // Tests if touch events are supported, but doesn't necessarily reflect a touchscreen device
  var touch = Boolean('ontouchstart' in window || window.navigator && window.navigator.msPointerEnabled && window.MSGesture || window.DocumentTouch && document instanceof DocumentTouch);

  var pointer = window.PointerEvent || window.MSPointerEvent ? true : false; // eslint-disable-line no-unneeded-ternary

  function pointerEvent(pointerEvent) {
    return window.MSPointerEvent ? 'MSPointer' + pointerEvent.charAt(9).toUpperCase() + pointerEvent.substr(10) : pointerEvent;
  }

  exports.prefixedProperty = prefixedProperty;
  exports.transitionProperty = transitionProperty;
  exports.transformProperty = transformProperty;
  exports.animationProperty = animationProperty;
  exports.transitionEndEvent = transitionEndEvent;
  exports.animationEndEvent = animationEndEvent;
  exports.transform3D = transform3D;
  exports.transform = transform;
  exports.transition = transition;
  exports.canSticky = canSticky;
  exports.isSupportedSvg = isSupportedSvg;
  exports.touch = touch;
  exports.pointer = pointer;
  exports.pointerEvent = pointerEvent;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
