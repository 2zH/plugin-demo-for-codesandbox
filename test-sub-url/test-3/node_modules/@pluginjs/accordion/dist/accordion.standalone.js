(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global['@pluginjs/accordion'] = {})));
}(this, (function (exports) { 'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var defineProperty = function (obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  };

  var inherits = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };

  var possibleConstructorReturn = function (self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  };

  var slicedToArray = function () {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();

  var toConsumableArray = function (arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    } else {
      return Array.from(arr);
    }
  };

  var _extends$1 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  function datasetParse(dataset) {
    var data = Object.entries(dataset).reduce(function (result, _ref) {
      var _ref2 = slicedToArray(_ref, 2),
          k = _ref2[0],
          v = _ref2[1];

      try {
        var content = JSON.parse('{"data": ' + v.replace(/'/g, '"') + '}').data;
        return _extends$1({}, result, defineProperty({}, k, content));
      } catch (err) {
        return _extends$1({}, result, defineProperty({}, k, v));
      }
    }, {});
    return data;
  }

  var Plugin = function () {
    function Plugin(namespace, element) {
      classCallCheck(this, Plugin);

      this.plugin = namespace;
      this.element = element;
      if (window.Pj && window.Pj.instances[this.plugin]) {
        window.Pj.instances[this.plugin].push(this);
      }
    }

    createClass(Plugin, [{
      key: 'getDataOptions',
      value: function getDataOptions() {
        return datasetParse(this.element.dataset);
        // const data = this.element.dataset
        // const length = Object.keys(data).length
        // const newData = {}

        // if (length > 0) {
        //   Object.entries(data).forEach(([name, content]) => {
        //     let cache = {}
        //     const items = name.split('-')
        //     // let items = name.split('-');

        //     const deep = items.length

        //     if (deep > 1) {
        //       let buffer = {}

        //       for (let j = 0; j < deep; j++) {
        //         const item =
        //           items[j].substring(0, 1).toLowerCase() + items[j].substring(1)

        //         if (j === 0) {
        //           buffer = {}
        //           cache[item] = {}
        //         } else if (j === deep - 1) {
        //           buffer[item] = content
        //         } else {
        //           buffer = {}
        //           buffer[item] = {}
        //         }
        //       }
        //     } else if (
        //       items[0] ===
        //       `as${this.plugin
        //         .substring(0, 1)
        //         .toUpperCase()}${this.plugin.substring(1)}`
        //     ) {
        //       cache = content
        //     } else {
        //       cache[name] = content
        //     }

        //     Object.assign(newData, cache)
        //   })
        // }

        // return newData
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        var _this = this;

        this.plugin = null;
        this.element = null;
        if (window.Pj && window.Pj.instances[this.plugin]) {
          window.Pj.instances[this.plugin] = window.Pj.instances[this.plugin].filter(function (plugin) {
            return plugin.element === _this.element;
          });
        }
      }
    }], [{
      key: 'of',
      value: function of() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return new (Function.prototype.bind.apply(this, [null].concat(args)))();
      }
    }]);
    return Plugin;
  }();

  var _extends$2 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  function nub(arr) {
    return Array.from(new Set(arr));
  }
  function isPlainObject(data) {
    if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object') {
      return false;
    }

    if (data === null) {
      return false;
    }

    if (data instanceof Set || data instanceof Map) {
      return false;
    }

    if (Array.isArray(data)) {
      return false;
    }

    return true;
  }
  function deepMergeTwo(x, y) {
    if (isPlainObject(y) && isPlainObject(x) || isPlainObject(x) && Array.isArray(y)) {
      return fromPairs$1(nub(Object.keys(x).concat(Object.keys(y))).map(function (key) {
        return [key, deepMergeTwo(x[key], y[key])];
      }));
    }

    if (isPlainObject(y) && typeof x === 'function') {
      return Object.assign(function () {
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return x.apply(this, args);
      }, y);
    }

    if (isPlainObject(y) && Array.isArray(x)) {
      return Object.assign([], x, y);
    }

    if (isPlainObject(x) && typeof y === 'function') {
      return Object.assign(function () {
        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        return y.apply(this, args);
      }, x);
    }

    if (Array.isArray(y) && Array.isArray(x)) {
      // return x.concat(y)
      return nub(Object.keys(y).concat(Object.keys(x))).map(function (index) {
        return deepMergeTwo(x[index], y[index]);
      });
    }

    if (typeof y === 'undefined') {
      return x;
    }
    return y;
  }
  function isObject(obj) {
    return Object(obj) === obj;
  }
  function deepMerge() {
    for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    return args.filter(isObject).reduce(deepMergeTwo);
  }

  var curry = function curry(fn) {
    var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    return function () {
      for (var _len5 = arguments.length, subArgs = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        subArgs[_key5] = arguments[_key5];
      }

      var currylen = fn.currylen || fn.length;
      var collect = args.concat(subArgs);
      if (collect.length >= currylen) {
        return fn.apply(undefined, toConsumableArray(collect));
      }
      return curry(fn, collect);
    };
  };

  var compose = function compose() {
    for (var _len6 = arguments.length, fn = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      fn[_key6] = arguments[_key6];
    }

    var callback = function callback() {
      for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }

      return fn.reduceRight(function (r, i, index) {
        if (Array.isArray(r) && index === fn.length - 1) {
          return i.apply(undefined, toConsumableArray(r));
        }
        return i(r);
      }, args);
    };
    callback.currylen = fn[fn.curylen || fn.length - 1].length;
    return callback;
  };

  function camelize(word) {
    var first = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    word = word.replace(/[_.-\s](\w|$)/g, function (_, x) {
      return x.toUpperCase();
    });

    if (first) {
      word = word.substring(0, 1).toUpperCase() + word.substring(1);
    }
    return word;
  }

  /* Credit to https://github.com/jonschlinkert/get-value MIT */
  function getValueByPath(obj, path) {
    if (Object(obj) !== obj || typeof path === 'undefined') {
      return obj;
    }

    if (path in obj) {
      return obj[path];
    }

    var segs = path.split('.');
    var length = segs.length;
    if (!length) {
      return undefined;
    }
    var i = -1;

    while (obj && ++i < length) {
      var key = segs[i];
      while (key[key.length - 1] === '\\') {
        key = key.slice(0, -1) + '.' + segs[++i];
      }
      obj = obj[key];
    }
    return obj;
  }

  /* Throttle execution of a function.
   * Especially useful for rate limiting execution of
   * handlers on events like resize and scroll. */
  function throttle(func, delay) {
    var _this = this;

    var running = false;
    function resetRunning() {
      running = false;
    }

    if (delay !== undefined || delay !== null) {
      return function () {
        for (var _len8 = arguments.length, args = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
          args[_key8] = arguments[_key8];
        }

        var that = _this;

        if (running) {
          return;
        }
        running = true;
        func.apply(that, args);
        window.setTimeout(resetRunning, delay);
      };
    }

    return function () {
      for (var _len9 = arguments.length, args = Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        args[_key9] = arguments[_key9];
      }

      var that = _this;

      if (running) {
        return;
      }
      running = true;
      window.requestAnimationFrame(function () {
        func.apply(that, args);
        resetRunning();
      });
    };
  }

  function fromPairs$1(arr) {
    return arr.reduce(function (r, _ref10) {
      var _ref11 = slicedToArray(_ref10, 2),
          k = _ref11[0],
          v = _ref11[1];

      return _extends$2({}, r, defineProperty({}, k, v));
    }, {});
  }

  /*eslint-disable */
  /* Credit to http://is.js.org MIT */
  var toString = Object.prototype.toString;
  var is = {
    // Type checks
    /* -------------------------------------------------------------------------- */
    // is a given value Arguments?
    arguments: function _arguments(value) {
      // fallback check is for IE
      return toString.call(value) === '[object Arguments]' || value != null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && 'callee' in value;
    },

    // is a given value Array?
    array: function array(val) {
      if (Array.isArray) {
        return Array.isArray(val);
      }
      return toString.call(val) === '[object Array]';
    },

    // is a given value Boolean?
    boolean: function boolean(val) {
      return val === true || val === false || toString.call(val) === '[object Boolean]';
    },

    // is a given value Char?
    char: function char(val) {
      return this.string(val) && val.length === 1;
    },

    // is a given value Date Object?
    date: function date(value) {
      return toString.call(value) === '[object Date]';
    },

    // is a given object a DOM node?
    domNode: function domNode(object) {
      return this.object(object) && object.nodeType > 0;
    },

    // is a given value Error object?
    error: function error(val) {
      return toString.call(val) === '[object Error]';
    },

    // is a given value function?
    function: function _function(val) {
      // fallback check is for IE
      return toString.call(val) === '[object Function]' || typeof val === 'function';
    },

    // is given value a pure JSON object?
    json: function json(value) {
      return toString.call(value) === '[object Object]';
    },

    // is a given value NaN?
    nan: function nan(val) {
      // NaN is number :) Also it is the only value which does not equal itself
      return val !== val;
    },

    // is a given value null?
    null: function _null(val) {
      return val === null;
    },

    // is a given value number?
    number: function number(val) {
      return !this.nan(val) && toString.call(val) === '[object Number]';
    },

    // is a given value object?
    object: function object(val) {
      return Object(val) === val;
    },

    // is a given value empty object?
    emptyObject: function emptyObject(val) {
      return this.object(val) && Object.getOwnPropertyNames(val).length == 0;
    },

    // is a given value RegExp?
    regexp: function regexp(val) {
      return toString.call(val) === '[object RegExp]';
    },

    // is a given value String?
    string: function string(val) {
      return typeof val === 'string' || toString.call(val) === '[object String]';
    },

    // is a given value undefined?
    undefined: function undefined(val) {
      return val === void 0;
    },

    // Arithmetic checks
    /* -------------------------------------------------------------------------- */
    // is a given value numeric?
    numeric: function numeric(n) {
      return (this.number(n) || this.string(n)) && !this.nan(n - parseFloat(n));
    },

    // is a given number percentage?
    percentage: function percentage(n) {
      return typeof n === 'string' && n.indexOf('%') !== -1;
    },

    // is a given number decimal?
    decimal: function decimal(n) {
      return this.number(n) && n % 1 !== 0;
    },

    // is a given number finite?
    finite: function finite(n) {
      if (isFinite) {
        return isFinite(n);
      }
      return !this.infinite(n) && !this.nan(n);
    },

    // is a given number infinite?
    infinite: function infinite(n) {
      return n === Infinity || n === -Infinity;
    },

    integer: function integer(n) {
      return this.number(n) && n % 1 === 0;
    },

    // is a given number negative?
    negative: function negative(n) {
      return this.number(n) && n < 0;
    },

    // is a given number positive?
    positive: function positive(n) {
      return this.number(n) && n > 0;
    }
  };

  var query = function query(selector) {
    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
    return parent.querySelector(selector);
  };

  var find = curry(function (selector, parent) {
    return parent.querySelector(selector);
  });

  var remove = function remove(el) {
    return el.remove();
  };

  var html = curry(function (content, el) {
    el.innerHTML = content;
    return el;
  });

  var children = function children(el) {
    if (!el) {
      return null;
    }
    return Array.from(el.children);
  };

  var parent = function parent(el) {
    return el.parentNode;
  };
  // 解析 HTML/SVG/XML 字符串
  var parseHTML = function parseHTML() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var htmlString = Array.isArray(args[0]) ? args[0].reduce(function (result, str, index) {
      return result + args[index] + str;
    }) : args[0];
    var childNodes = compose(children, html(htmlString))(document.createElement('div'));
    if (childNodes.length === 1) {
      return childNodes[0];
    }
    return childNodes;
  };

  var empty = function empty(el) {
    el.innerHTML = '';
    return el;
  };
  var removeAttribute = curry(function (name, el) {
    return el.removeAttribute(name);
  });

  var append = curry(function (child, el) {
    if (is.string(child)) {
      el.insertAdjacentHTML('beforeend', child);
    } else {
      el.append(child);
    }
    return el;
  });

  var insertBefore = curry(function (newElement, el) {
    if (is.string(newElement)) {
      el.insertAdjacentHTML('beforebegin', newElement);
    } else {
      el.insertAdjacentElement('beforebegin', newElement);
    }
    return el;
  });

  var parentWith = curry(function (fn, el) {
    var parentElement = parent(el);
    // console.log(el, parentElement)
    if (!parentElement || parentElement === document) {
      return false;
    }
    if (fn(parentElement)) {
      return parentElement;
    }
    return parentWith(fn, parentElement);
  });

  // == animation == //

  var fade = curry(function (type, _ref9, element) {
    var duration = _ref9.duration,
        callback = _ref9.callback;

    var isIn = type === 'in';
    var opacity = isIn ? 0 : 1;
    var start = null;

    if (isIn) {
      if (element.style.display === 'none') {
        element.style.display = 'inline';
      }
      element.style.opacity = opacity;
    }

    function step(timestamp) {
      if (!start) {
        start = timestamp;
      }
      var progress = timestamp - start;
      var percent = progress / duration;
      opacity = isIn ? opacity + percent : opacity - percent;
      element.style.opacity = opacity;

      if (opacity <= 0) {
        element.style.display = 'none';
      }

      if (progress < duration) {
        window.requestAnimationFrame(step);
      } else if (callback) {
        callback();
      }
    }

    window.requestAnimationFrame(step);
  });

  var fadeOut = fade('out');
  var fadeIn = fade('in');

  var isElement = function isElement(el) {
    return el instanceof Element;
  };

  var curryWith = function curryWith(fn, enSureFunction) {
    var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    return function () {
      for (var _len = arguments.length, subArgs = Array(_len), _key = 0; _key < _len; _key++) {
        subArgs[_key] = arguments[_key];
      }

      var index = subArgs.findIndex(enSureFunction);
      if (index >= 0) {
        var _collect = args.concat.apply(args, toConsumableArray(subArgs.slice(0, index + 1)));
        return fn.apply(undefined, toConsumableArray(_collect));
      }
      var collect = args.concat.apply(args, subArgs);
      return curryWith(fn, enSureFunction, collect);
    };
  };

  // last:: [a] -> a
  var last = function last(arr) {
    return arr.slice(-1)[0];
  };

  // init :: [a] -> [a]
  var init = function init(arr) {
    return arr.slice(0, -1);
  };

  var hasClass = curry(function (className, element) {
    return element.classList.contains(className);
  });
  var addClass = curryWith(function () {
    var _element$classList;

    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    var classes = init(args);
    var element = last(args);
    (_element$classList = element.classList).add.apply(_element$classList, toConsumableArray(classes));
    return element;
  }, isElement);
  var removeClass = curryWith(function () {
    var _element$classList2;

    for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    var classes = init(args);
    var element = last(args);
    (_element$classList2 = element.classList).remove.apply(_element$classList2, toConsumableArray(classes));
    return element;
  }, isElement);
  var toggleClass = curry(function (className, element) {
    element.classList.toggle(className);
    return element;
  });

  var outputIdentity = function outputIdentity(identity) {
    if (!identity) {
      return { type: 'self', value: '' };
    }
    if (typeof identity === 'string') {
      return { type: 'selector', value: identity };
    }

    return identity;
  };

  var tupleToStyleSelector = function tupleToStyleSelector(tuple, prefix) {
    if (typeof tuple === 'string') {
      return tuple;
    }
    return Object.entries(tuple).map(function (kv) {
      return '[' + prefix + kv.join('=') + ']';
    }).join('');
  };

  var dispatch = function dispatch(event) {
    var target = event.target,
        currentTarget = event.currentTarget;

    var eventStorage = EventStorage.getEventStorage(currentTarget);
    var eventName = event.type;

    var attrVerify$$1 = {
      self: function self(node) {
        return node === currentTarget;
      },
      class: function _class(node, value) {
        return node.matches('.' + value);
      },
      selector: function selector(node, value) {
        return node.matches(value);
      },
      id: function id(node, value) {
        return node.matches('#' + value);
      },
      tagName: function tagName(node, value) {
        return node.matches(value);
      },
      dom: function dom(node, value) {
        return node === value;
      },
      dataset: function dataset$$1(node, value) {
        return node.matches(tupleToStyleSelector(value, 'data-'));
      },
      attribute: function attribute(node, value) {
        return node.matches(tupleToStyleSelector(value));
      },
      func: function func(node, value) {
        return Boolean(value(node));
      }
    };

    var nodeTreeCheck = function nodeTreeCheck(node) {
      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      if (!currentTarget.contains(node)) {
        return result;
      }

      var matchEventList = eventStorage.listeners[eventName].filter(function (_ref) {
        var identity = _ref.identity;
        var type = identity.type,
            value = identity.value;

        var identityMapper = attrVerify$$1[type];
        if (identityMapper && identityMapper(node, value)) {
          return true;
        }
        return false;
      });
      return nodeTreeCheck(parent(node), result.concat(matchEventList));
    };
    // nodeTreeCheck(target).map(e => console.log(e.handler.toString()))
    nodeTreeCheck(target).reduce(function (result, _ref2) {
      var handler = _ref2.handler;
      return result !== false && handler(event);
    }, true);
  };

  var EventStorage = function () {
    function EventStorage(element) {
      classCallCheck(this, EventStorage);

      this.element = element;
      this.listeners = {};
    }

    createClass(EventStorage, [{
      key: 'on',
      value: function on(_ref3) {
        var identity = _ref3.identity,
            handler = _ref3.handler,
            eventName = _ref3.eventName,
            namespace = _ref3.namespace;

        this.ensureHandler(handler);

        if (!this.hasListeners(eventName)) {
          this.createEventListener(eventName);
        }

        if (this.checkRepeats(eventName, handler)) {
          return;
        }

        this.listeners[eventName].push({ identity: identity, handler: handler, namespace: namespace });
      }
    }, {
      key: 'once',
      value: function once(_ref4) {
        var _this = this;

        var identity = _ref4.identity,
            handler = _ref4.handler,
            eventName = _ref4.eventName,
            namespace = _ref4.namespace;

        this.ensureHandler(handler);

        if (!this.hasListeners(eventName)) {
          this.createEventListener(eventName);
        }

        var callback = function callback(event) {
          _this.removeListener(eventName, callback);

          return handler(event);
        };

        this.listeners[eventName].push({ identity: identity, handler: callback, namespace: namespace });
      }
    }, {
      key: 'off',
      value: function off(_eventName, handler) {
        if (typeof handler === 'undefined') {
          return this.removeAllListeners(_eventName);
        }
        return this.removeListener(_eventName, handler);
      }
    }, {
      key: 'trigger',
      value: function trigger(eventName, data) {
        var event = new CustomEvent(eventName, {
          detail: data
        });
        this.element.dispatchEvent(event);
      }
    }, {
      key: 'clear',
      value: function clear() {
        var _this2 = this;

        Object.entries(this.listeners).map(function (_ref5) {
          var _ref6 = slicedToArray(_ref5, 2),
              key = _ref6[0],
              value = _ref6[1];

          _this2.deleteEventListener(key);
        });

        this.listener = {};
      }
    }, {
      key: 'removeListener',
      value: function removeListener(_eventName, handler) {
        var _this3 = this;

        var _eventName$split = _eventName.split('.'),
            _eventName$split2 = slicedToArray(_eventName$split, 2),
            eventName = _eventName$split2[0],
            namespace = _eventName$split2[1];
        //   .example  || click  || click.example


        if (!eventName && namespace) {
          Object.entries(this.listeners).map(function (_ref7) {
            var _ref8 = slicedToArray(_ref7, 2),
                key = _ref8[0],
                value = _ref8[1];

            _this3.listeners[key] = _this3.listeners[key].filter(function (eventTuple) {
              return eventTuple.handler !== handler || eventTuple.namespace !== namespace;
            });

            if (_this3.listeners[key].length === 0) {
              _this3.deleteEventListener(key);
            }
          });
        } else if (eventName && !namespace) {
          // console.log('eventName')
          this.listeners[eventName] = this.listeners[eventName].filter(function (eventTuple) {
            return eventTuple.handler !== handler;
          });

          if (this.listeners[eventName].length === 0) {
            this.deleteEventListener(eventName);
          }
        } else if (eventName && namespace) {
          this.listeners[eventName] = this.listeners[eventName].filter(function (eventTuple) {
            return eventTuple.handler !== handler || eventTuple.namespace !== namespace;
          });

          if (this.listeners[eventName].length === 0) {
            this.deleteEventListener(eventName);
          }
        }
      }
    }, {
      key: 'removeAllListeners',
      value: function removeAllListeners(_eventName) {
        var _this4 = this;

        var _eventName$split3 = _eventName.split('.'),
            _eventName$split4 = slicedToArray(_eventName$split3, 2),
            eventName = _eventName$split4[0],
            namespace = _eventName$split4[1];
        //   .example  || click  || click.example


        if (!eventName && namespace) {
          Object.entries(this.listeners).map(function (_ref9) {
            var _ref10 = slicedToArray(_ref9, 2),
                key = _ref10[0],
                value = _ref10[1];

            _this4.listeners[key] = _this4.listeners[key].filter(function (eventTuple) {
              return eventTuple.namespace !== namespace;
            });

            if (_this4.listeners[key].length === 0) {
              _this4.deleteEventListener(key);
            }
          });
        } else if (eventName && !namespace) {
          this.deleteEventListener(eventName);
        } else if (eventName && namespace && this.listeners[eventName]) {
          this.listeners[eventName] = this.listeners[eventName].filter(function (eventTuple) {
            return eventTuple.namespace !== namespace;
          });

          if (this.listeners[eventName].length === 0) {
            this.deleteEventListener(eventName);
          }
        }

        return this;
      }
    }, {
      key: 'createEventListener',
      value: function createEventListener(eventName) {
        this.listeners[eventName] = [];
        this.element.addEventListener(eventName, dispatch, false);
      }
    }, {
      key: 'deleteEventListener',
      value: function deleteEventListener(eventName) {
        this.element.removeEventListener(eventName, dispatch);
        delete this.listeners[eventName];
      }
    }, {
      key: 'checkRepeats',
      value: function checkRepeats(eventName, handler) {
        return this.listeners[eventName].filter(function (value) {
          return value.handler === handler;
        }).length !== 0;
      }
    }, {
      key: 'hasListeners',
      value: function hasListeners(eventName) {
        if (!this.listeners[eventName] || Object.keys(this.listeners[eventName]).length === 0) {
          return false;
        }

        return true;
      }
    }, {
      key: 'ensureHandler',
      value: function ensureHandler(handler) {
        var type = typeof handler === 'undefined' ? 'undefined' : _typeof(handler);
        if (type === 'function') {
          return handler;
        }
        throw new TypeError('Listeners should be function or closure. Received type: ' + type);
      }
    }], [{
      key: 'of',
      value: function of(_ref11, element) {
        var _eventName = _ref11.type,
            identity = _ref11.identity,
            handler = _ref11.handler;

        if (!element.__eventStorage) {
          element.__eventStorage = new this(element);
        }

        var _eventName$split5 = _eventName.split('.'),
            _eventName$split6 = slicedToArray(_eventName$split5, 2),
            eventName = _eventName$split6[0],
            namespace = _eventName$split6[1];

        var eventStorage = this.getEventStorage(element);

        eventStorage.on({
          identity: outputIdentity(identity),
          handler: handler,
          eventName: eventName,
          namespace: namespace
        });
      }
    }, {
      key: 'once',
      value: function once(_ref12, element) {
        var _eventName = _ref12.type,
            identity = _ref12.identity,
            handler = _ref12.handler;

        if (!element.__eventStorage) {
          element.__eventStorage = new this(element);
        }

        var _eventName$split7 = _eventName.split('.'),
            _eventName$split8 = slicedToArray(_eventName$split7, 2),
            eventName = _eventName$split8[0],
            namespace = _eventName$split8[1];

        var eventStorage = this.getEventStorage(element);

        eventStorage.once({
          identity: outputIdentity(identity),
          handler: handler,
          eventName: eventName,
          namespace: namespace
        });
      }
    }, {
      key: 'delete',
      value: function _delete(options, element) {
        var eventStorage = this.getEventStorage(element);
        if (!eventStorage) {
          return;
        }

        var _options$type = options.type,
            _eventName = _options$type === undefined ? options : _options$type,
            handler = options.handler;

        eventStorage.off(_eventName, handler);
      }
    }, {
      key: 'getEventStorage',
      value: function getEventStorage(element) {
        return element.__eventStorage;
      }
    }]);
    return EventStorage;
  }();

  var trigger = curry(function (options, el) {
    if (options instanceof window.Event) {
      el.dispatchEvent(options);
      return el;
    }
    var _options$type2 = options.type,
        type = _options$type2 === undefined ? options : _options$type2,
        data = options.data;

    var eventName = type;

    var eventStorage = EventStorage.getEventStorage(el);
    if (eventStorage && eventStorage.hasListeners(eventName)) {
      eventStorage.trigger(eventName, data);
    }

    return el;
  });
  /**
   * bindEvent ({
   *   type: 'example:CustomEvent',
   *   handler: event => {
   *     let { instance } = event.detail
   *   }
   * }, elemment)
   *
   * trigger({
   *   type: 'example:CustomEvent',
   *   data: {instance: this}
   * }, elemment)
   */

  var bindEvent = curry(function (options, element) {
    EventStorage.of(options, element);
    return element;
  });

  var Emitter = function () {
    function Emitter() {
      classCallCheck(this, Emitter);

      this.listeners = {};
      this.sortedListeners = {};
    }

    createClass(Emitter, [{
      key: 'emit',
      value: function emit(event) {
        var listeners = this.getListeners(event);

        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        for (var i = 0; i < listeners.length; i++) {
          var context = null;

          if (listeners[i].context !== null) {
            context = listeners[i].context;
          } else {
            context = { type: event };
          }

          var result = listeners[i].listener.apply(context, args);

          if (result === false) {
            return false;
          }
        }

        return true;
      }
    }, {
      key: 'on',
      value: function on(event, listener, context, priority) {
        return this.addListener(event, listener, context, priority);
      }
    }, {
      key: 'once',
      value: function once(event, listener, context, priority) {
        return this.addOneTimeListener(event, listener, context, priority);
      }
    }, {
      key: 'off',
      value: function off(event, listener) {
        if (typeof listener === 'undefined') {
          return this.removeAllListeners(event);
        }

        return this.removeListener(event, listener);
      }

      /* Lower numbers correspond with earlier execution,
      /* and functions with the same priority are executed
      /* in the order in which they were added to the action. */

    }, {
      key: 'addListener',
      value: function addListener(event, listener) {
        var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var priority = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;

        this.ensureListener(listener);

        if (!this.listeners[event]) {
          this.listeners[event] = {};
        }
        if (!this.listeners[event][priority]) {
          this.listeners[event][priority] = [];
        }

        this.listeners[event][priority].push({
          context: context,
          listener: listener
        });
        this.clearSortedListeners(event);

        return this;
      }
    }, {
      key: 'addOneTimeListener',
      value: function addOneTimeListener(event, listener, context) {
        var priority = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;

        var that = this;
        function wrapper() {
          that.removeListener(event, wrapper);

          return listener.apply(undefined, arguments);
        }

        this.addListener(event, wrapper, context, priority);

        return this;
      }
    }, {
      key: 'removeListener',
      value: function removeListener(event, listener) {
        this.clearSortedListeners(event);
        var listeners = this.hasListeners(event) ? this.listeners[event] : [];

        for (var priority in listeners) {
          if (Object.prototype.hasOwnProperty.call(listeners, priority)) {
            listeners[priority] = listeners[priority].filter(function (value) {
              return value.listener !== listener;
            });

            if (listeners[priority].length === 0) {
              delete listeners[priority];
            }
          }
        }

        this.listeners[event] = listeners;

        return this;
      }
    }, {
      key: 'removeAllListeners',
      value: function removeAllListeners(event) {
        this.clearSortedListeners(event);

        if (this.hasListeners(event)) {
          delete this.listeners[event];
        }

        return this;
      }
    }, {
      key: 'ensureListener',
      value: function ensureListener(listener) {
        var type = typeof listener === 'undefined' ? 'undefined' : _typeof(listener);
        if (type === 'function') {
          return listener;
        }
        throw new TypeError('Listeners should be function or closure. Received type: ' + type);
      }
    }, {
      key: 'hasListeners',
      value: function hasListeners(event) {
        if (!this.listeners[event] || Object.keys(this.listeners[event]).length === 0) {
          return false;
        }

        return true;
      }
    }, {
      key: 'getListeners',
      value: function getListeners(event) {
        if (!this.sortedListeners.hasOwnProperty(event)) {
          this.sortedListeners[event] = this.getSortedListeners(event);
        }

        return this.sortedListeners[event];
      }
    }, {
      key: 'getSortedListeners',
      value: function getSortedListeners(event) {
        if (!this.hasListeners(event)) {
          return [];
        }

        var listeners = this.listeners[event];

        var priorities = Object.keys(listeners);
        priorities.sort(function (a, b) {
          return a - b;
        });

        var sortedlisteners = [];
        for (var i = 0; i < priorities.length; i++) {
          sortedlisteners = sortedlisteners.concat(listeners[priorities[i]]);
        }

        return sortedlisteners;
      }
    }, {
      key: 'clearSortedListeners',
      value: function clearSortedListeners(event) {
        delete this.sortedListeners[event];
      }
    }]);
    return Emitter;
  }();

  var _extends$3 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  function datasetParse$1(dataset) {
    var data = Object.entries(dataset).reduce(function (result, _ref) {
      var _ref2 = slicedToArray(_ref, 2),
          k = _ref2[0],
          v = _ref2[1];

      try {
        var content = JSON.parse('{"data": ' + v.replace(/'/g, '"') + '}').data;
        return _extends$3({}, result, defineProperty({}, k, content));
      } catch (err) {
        return _extends$3({}, result, defineProperty({}, k, v));
      }
    }, {});
    return data;
  }

  var Plugin$1 = function () {
    function Plugin(namespace, element) {
      classCallCheck(this, Plugin);

      this.plugin = namespace;
      this.element = element;
      if (window.Pj && window.Pj.instances[this.plugin]) {
        window.Pj.instances[this.plugin].push(this);
      }
    }

    createClass(Plugin, [{
      key: 'getDataOptions',
      value: function getDataOptions() {
        return datasetParse$1(this.element.dataset);
        // const data = this.element.dataset
        // const length = Object.keys(data).length
        // const newData = {}

        // if (length > 0) {
        //   Object.entries(data).forEach(([name, content]) => {
        //     let cache = {}
        //     const items = name.split('-')
        //     // let items = name.split('-');

        //     const deep = items.length

        //     if (deep > 1) {
        //       let buffer = {}

        //       for (let j = 0; j < deep; j++) {
        //         const item =
        //           items[j].substring(0, 1).toLowerCase() + items[j].substring(1)

        //         if (j === 0) {
        //           buffer = {}
        //           cache[item] = {}
        //         } else if (j === deep - 1) {
        //           buffer[item] = content
        //         } else {
        //           buffer = {}
        //           buffer[item] = {}
        //         }
        //       }
        //     } else if (
        //       items[0] ===
        //       `as${this.plugin
        //         .substring(0, 1)
        //         .toUpperCase()}${this.plugin.substring(1)}`
        //     ) {
        //       cache = content
        //     } else {
        //       cache[name] = content
        //     }

        //     Object.assign(newData, cache)
        //   })
        // }

        // return newData
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        var _this = this;

        this.plugin = null;
        this.element = null;
        if (window.Pj && window.Pj.instances[this.plugin]) {
          window.Pj.instances[this.plugin] = window.Pj.instances[this.plugin].filter(function (plugin) {
            return plugin.element === _this.element;
          });
        }
      }
    }], [{
      key: 'of',
      value: function of() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return new (Function.prototype.bind.apply(this, [null].concat(args)))();
      }
    }]);
    return Plugin;
  }();

  var GlobalComponent = function (_Plugin) {
    inherits(GlobalComponent, _Plugin);

    function GlobalComponent(namespace) {
      classCallCheck(this, GlobalComponent);

      var _this2 = possibleConstructorReturn(this, (GlobalComponent.__proto__ || Object.getPrototypeOf(GlobalComponent)).call(this, namespace, window.Pj.doc));

      if (!window.Pj.instances[_this2.plugin]) {
        return possibleConstructorReturn(_this2);
      }
      _this2.instanceId = window.Pj.instances[_this2.plugin].length + 1;
      window.Pj.instances[_this2.plugin].push(_this2);
      return _this2;
    }

    createClass(GlobalComponent, [{
      key: 'destroy',
      value: function destroy() {
        var _this3 = this;

        window.Pj.instances[this.plugin] = window.Pj.instances[this.plugin].filter(function (instance) {
          return instance !== _this3;
        });
        window.Pj[this.plugin] = null;
      }
    }]);
    return GlobalComponent;
  }(Plugin$1);

  /* Credit to https://github.com/jonschlinkert/get-value MIT */
  function getValueByPath$1(obj, path) {
    if (Object(obj) !== obj || typeof path === 'undefined') {
      return obj;
    }

    if (path in obj) {
      return obj[path];
    }

    var segs = path.split('.');
    var length = segs.length;
    if (!length) {
      return undefined;
    }
    var i = -1;

    while (obj && ++i < length) {
      var key = segs[i];
      while (key[key.length - 1] === '\\') {
        key = key.slice(0, -1) + '.' + segs[++i];
      }
      obj = obj[key];
    }
    return obj;
  }

  /* Credit to https://github.com/Matt-Esch/string-template MIT */
  var template = function () {
    var pattern = /\{\s*([.0-9a-zA-Z_]+)\s*\}/g;

    function render(string) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      if (args.length === 1 && _typeof(args[0]) === 'object') {
        args = args[0];
      }

      if (!args || !args.hasOwnProperty) {
        args = {};
      }

      return string.replace(pattern, function (match, i, index) {
        var result = null;

        if (string[index - 1] === '{' && string[index + match.length] === '}') {
          return i;
        }

        if (args.hasOwnProperty(i)) {
          result = args[i];
        } else if (i.indexOf('.') !== -1) {
          result = getValueByPath$1(args, i);
        }

        if (result === null || result === undefined) {
          return '';
        }

        return result;
      });
    }

    return {
      render: render,
      compile: function compile(str) {
        return function () {
          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          return render.apply(undefined, [str].concat(args));
        };
      },
      parse: function parse(str) {
        var matches = str.match(pattern);

        if (matches === null) {
          return false;
        }

        var parsed = [];
        for (var i = 0; i < matches.length; i++) {
          if (!matches[i].match(/^\{\{.+\}\}$/g)) {
            parsed.push(matches[i].substring(1, matches[i].length - 1).trim());
          }
        }

        return parsed;
      }
    };
  }();

  var I18N = function () {
    function I18N(defaults$$1, translations) {
      classCallCheck(this, I18N);

      this.defaults = deepMerge({}, I18N.defaults, defaults$$1);

      this.translations = translations ? translations : {};
    }

    createClass(I18N, [{
      key: 'hasTranslation',
      value: function hasTranslation(locale) {
        return locale in this.translations;
      }
    }, {
      key: 'addTranslation',
      value: function addTranslation(locale, translation) {
        if (this.translations[locale]) {
          Object.assign(this.translations[locale], translation);
        } else {
          this.translations[locale] = translation;
        }
      }
    }, {
      key: 'getTranslation',
      value: function getTranslation(locale) {
        if (this.translations[locale]) {
          return this.translations[locale];
        }
        return {};
      }
    }, {
      key: 'instance',
      value: function instance() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var that = this;

        var _options = Object.assign({}, that.defaults, options);
        var _locale = _options.locale;

        function getMessage(key, locale) {
          var translation = that.getTranslation(locale);
          var message = getValueByPath(translation, key);

          return message;
        }

        return {
          translate: function translate(key) {
            var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var locale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _locale;

            var message = getMessage(key, locale);

            if (message === undefined && _options.fallbacks) {
              var locales = locale.split('-');
              if (locales.length > 1 && that.hasTranslation(locales[0])) {
                message = getMessage(key, locales[0]);
              }

              if (message === undefined) {
                var fallbackLocale = void 0;
                if (_options.fallbacks !== true && that.hasTranslation(_options.fallbacks)) {
                  fallbackLocale = _options.fallbacks;
                } else {
                  fallbackLocale = that.defaults.locale;
                }

                message = getMessage(key, fallbackLocale);
              }
            }

            if (Object.prototype.toString.call(message) === '[object Array]' && message.length >= 2) {
              if (typeof args._number === 'string') {
                if (typeof args[args._number] !== 'undefined') {
                  var _number = parseInt(args[args._number], 10);

                  if (_number === 1) {
                    message = message[0];
                  } else if (_number > 1) {
                    message = message[1];
                  } else if (_number === 0 && message.length >= 3) {
                    message = message[2];
                  }
                }
              }
            }

            if (typeof message === 'string') {
              var parsed = template.parse(message);
              if (!parsed) {
                return message;
              }
              var _key = void 0;
              for (var i = 0; i < parsed.length; i++) {
                _key = parsed[i];
                if (typeof args[_key] === 'undefined') {
                  args[_key] = _options.missingPlaceholder(_key);
                } else if (args[_key] === null) {
                  args[_key] = _options.nullPlaceholder(_key);
                }
              }
              return template.render(message, args);
            }

            if (Object(message) === message) {
              return message;
            }

            return '[missing "' + locale + '.' + key + '" translation]';
          },
          setLocale: function setLocale(locale) {
            _locale = locale;
          },
          getLocale: function getLocale() {
            return _locale;
          }
        };
      }
    }, {
      key: 'setTranslations',
      value: function setTranslations(translations) {
        this.translations = translations;
      }
    }]);
    return I18N;
  }();

  I18N.defaults = {
    locale: 'en',
    fallbacks: true,
    nullPlaceholder: function nullPlaceholder(key) {
      return '[missing {{' + key + '}} value]';
    },
    missingPlaceholder: function missingPlaceholder(key) {
      return '[missing {{' + key + '}} value]';
    }
  };

  var _extends$4 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  var objectWithoutProperties$2 = function objectWithoutProperties(obj, keys) {
    var target = {};

    for (var i in obj) {
      if (keys.indexOf(i) >= 0) continue;
      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
      target[i] = obj[i];
    }

    return target;
  };

  // import './polyfills'

  var envParamters = {
    body: window.document.body,
    doc: window.document
  };

  if (!window.Pj) {
    window.Pj = _extends$4({}, envParamters, {
      emitter: new Emitter(),
      plugins: {},
      instances: {},
      get windowWidth() {
        return window.document.documentElement.clientWidth;
      },
      get windowHeight() {
        return window.document.documentElement.clientHeight;
      },
      get: function get(name) {
        if (typeof this.plugins[name] !== 'undefined') {
          return this.plugins[name];
        }
        return null;
      }
    });
  }

  var Pj = window.Pj;

  function globalResizeHandle() {
    Pj.emitter.emit('resize');
  }

  function globalScrollHanle() {
    Pj.emitter.emit('scroll');
  }

  function register(name) {
    var obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var info = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    return function (plugin) {
      var _obj$defaults = obj.defaults,
          options = _obj$defaults === undefined ? {} : _obj$defaults,
          _obj$methods = obj.methods,
          methods = _obj$methods === undefined ? [] : _obj$methods,
          _obj$dependencies = obj.dependencies,
          dependencies = _obj$dependencies === undefined ? {} : _obj$dependencies,
          others = objectWithoutProperties$2(obj, ['defaults', 'methods', 'dependencies']);


      Pj.instances[name] = [];

      Pj.plugins[name] = Object.assign(plugin, _extends$4({
        setDefaults: function setDefaults() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          plugin.defaults = deepMerge(plugin.defaults, options);
        },

        defaults: plugin.defaults ? deepMerge(plugin.defaults, options) : options,
        methods: plugin.methods ? deepMerge(plugin.methods, methods) : methods,
        dependencies: plugin.dependencies ? deepMerge(plugin.dependencies, dependencies) : dependencies
      }, others), info);

      if (plugin.prototype.resize && is.undefined(plugin.resize)) {
        plugin.resize = function () {
          var instances = Pj.instances[name];

          for (var i = 0; i < instances.length; i++) {
            instances[i].resize(Pj.windowWidth, Pj.windowHeight);
          }
        };
      }

      if (is.function(plugin.resize)) {
        Pj.emitter.on('resize', plugin.resize);
      }

      if (plugin.prototype instanceof GlobalComponent) {
        Pj[name] = plugin;
      } else {
        Pj[name] = function (selector, options) {
          var elements = Array.from(typeof selector === 'string' ? document.querySelectorAll(selector) : [].concat(selector));
          if (!elements.length) {
            console.log(elements);
            throw new Error('element is not exists');
          }
          var instances = elements.map(function (el) {
            return plugin.of(el, options);
          });
          if (instances.length === 1) {
            return instances[0];
          }
          return instances;
        };
        Object.setPrototypeOf(Pj[name], plugin);
        // const APIS = []
        // const apiCallback = (method, ...args) => {
        //   const res = []
        //   APIS.map(api => {
        //     res.push(api(method, ...args))
        //   })
        //   if (res.length !== 1) {
        //     return res
        //   }
        //   return res[0]
        // }

        // elements.forEach(element => {
        //   const instance = plugin.of(element, options)
        //   const API = (method, ...args) => {
        //     if (!methods.includes(method)) {
        //       throw new Error(`not find method: ${method}`)
        //     }

        //     if (
        //       /^get/.test(method) ||
        //       /^is/.test(method) ||
        //       (method === 'val' && args.length === 0)
        //     ) {
        //       if (instance && typeof instance[method] === 'function') {
        //         return instance[method](...args)
        //       }
        //       return element
        //     }

        //     if (typeof instance[method] === 'function') {
        //       return instance[method](...args)
        //     }
        //   }
        //   APIS.push(API)
        // })
        // return apiCallback
        // }
      }
      return plugin;
    };
  }

  function stateable() {
    return function (plugin) {
      plugin.prototype.initStates = function () {
        var states = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        this._states = states;
      };

      // Checks whether the plugin is in a specific state or not.
      plugin.prototype.is = function (state) {
        if (this._states[state] && this._states[state] > 0) {
          return true;
        }
        return false;
      };

      // Enters a state.
      plugin.prototype.enter = function (state) {
        if (this._states[state] === undefined) {
          this._states[state] = 0;
        }

        // this._states[state]++;
        this._states[state] = 1;
      };

      // Leaves a state.
      plugin.prototype.leave = function (state) {
        if (this._states[state] === undefined) {
          this._states[state] = 0;
        }

        // this._states[state]--;
        this._states[state] = 0;
      };
    };
  }

  function eventable() {
    var events = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    return function (plugin) {
      plugin.events = events;

      plugin.setEvents = function () {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        deepMerge(plugin.events, options);
      };

      plugin.prototype.eventName = function (events) {
        if (typeof events !== 'string' || events === '') {
          return '.' + this.plugin;
        }
        events = events.split(' ');

        var length = events.length;
        for (var i = 0; i < length; i++) {
          events[i] = events[i] + '.' + this.plugin;
        }
        return events.join(' ');
      };

      plugin.prototype.eventNameWithId = function (events) {
        if (typeof events !== 'string' || events === '') {
          return '.' + this.plugin + '-' + this.instanceId;
        }

        events = events.split(' ');

        var length = events.length;
        for (var i = 0; i < length; i++) {
          events[i] = events[i] + '.' + this.plugin + '-' + this.instanceId;
        }
        return events.join(' ');
      };

      plugin.prototype.trigger = function (eventType) {
        for (var _len = arguments.length, params = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          params[_key - 1] = arguments[_key];
        }

        if (eventType instanceof Event) {
          trigger(eventType, this.element);
          var type = camelize(eventType.type);
          var onFunction = 'on' + type;

          if (typeof this.options[onFunction] === 'function') {
            this.options[onFunction].apply(this, params);
          }
        } else {
          trigger({
            type: this.plugin + ':' + eventType,
            data: { instance: this, data: params }
          }, this.element);
          eventType = camelize(eventType);
          var _onFunction = 'on' + eventType;
          if (typeof this.options[_onFunction] === 'function') {
            this.options[_onFunction].apply(this, [].concat(params, [this]));
          }
        }
      };

      plugin.prototype.selfEventName = function (eventType) {
        return this.plugin + ':' + eventType;
      };
    };
  }

  function themeable() {
    return function (plugin) {
      plugin.prototype.getThemeClass = function (themes, THEME) {
        if (is.undefined(themes) && this.options.theme) {
          return this.getThemeClass(this.options.theme);
        }
        if (is.string(themes)) {
          if (is.undefined(THEME)) {
            THEME = this.classes.THEME;
          }
          themes = themes.split(' ');

          if (THEME) {
            for (var i = 0; i < themes.length; i++) {
              themes[i] = THEME.replace('{theme}', themes[i]);
            }
          } else {
            for (var _i = 0; _i < themes.length; _i++) {
              themes[_i] = this.getClass(themes[_i]);
            }
          }
          return themes.join(' ');
        }

        return '';
      };
    };
  }

  function styleable() {
    var classes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    return function (plugin) {
      plugin.classes = classes;
      plugin.setClasses = function () {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        deepMerge(plugin.classes, options);
      };

      plugin.prototype.getClass = function (classname, arg, value) {
        if (!is.undefined(arg)) {
          return this.getClass(classname.replace('{' + arg + '}', value));
        }
        return classname.replace('{namespace}', this.classes.NAMESPACE || '');
      };

      plugin.prototype.initClasses = function (defaults$$1, options) {
        var _this = this;

        if (is.undefined(options) && is.object(this.options.classes)) {
          options = this.options.classes;
        }

        function conventKeyToUpperCase(obj) {
          var upperObj = {};
          for (var name in obj) {
            if (Object.hasOwnProperty.call(obj, name)) {
              if (is.string(obj[name])) {
                upperObj[name.toUpperCase()] = obj[name];
              } else if (is.object(obj[name])) {
                upperObj[name.toUpperCase()] = conventKeyToUpperCase(obj[name]);
              }
            }
          }
          return upperObj;
        }

        this.classes = deepMerge({}, defaults$$1, conventKeyToUpperCase(options || {}));

        if (!is.undefined(this.classes.NAMESPACE)) {
          var injectNamespace = function injectNamespace(obj) {
            for (var name in obj) {
              if (Object.hasOwnProperty.call(obj, name)) {
                if (is.string(obj[name])) {
                  obj[name] = _this.getClass(obj[name]);
                } else if (is.object(obj[name])) {
                  obj[name] = injectNamespace(obj[name]);
                }
              }
            }
            return obj;
          };

          this.classes = injectNamespace(this.classes);
        }
      };
    };
  }

  window.addEventListener('orientationchange', globalResizeHandle);
  window.addEventListener('resize', throttle(globalResizeHandle));
  window.addEventListener('scroll', throttle(globalScrollHanle));

  var namespace = 'accordion';

  var events = {
    READY: 'ready',
    OPEN: 'open',
    CLOSE: 'close',
    RESIZE: 'resize'
  };

  var classes = {
    NAMESPACE: 'pj-' + namespace,
    THEME: '{namespace}--{theme}',
    ACTIVE: '{namespace}-active',
    DISABLED: '{namespace}-disabled',

    RESPONSIVE: '{namespace}-responsive',
    HORIZONTAL: '{namespace}-horizontal',

    DROPDOWN: '{namespace}-dropdown',
    DROPDOWNLABEL: '{namespace}-dropdown-label',
    DROPDOWNLIST: '{namespace}-dropdown-list',
    DROPDOWNOPEN: '{namespace}-open',

    // components
    PANE: '{namespace}-pane',
    PANEHEADER: '{namespace}-pane-header',
    PANECONTENT: '{namespace}-pane-content',
    PANECONTENTINNER: '{namespace}-pane-content-inner'
  };

  var methods = ['open', 'close'];

  var defaults$1 = {
    theme: null,
    panelSelector: null,
    initialIndex: 0,
    duration: 300,
    horizontal: false,
    multiple: false,
    ajax: false,

    // Responsive
    breakWidth: null,
    resizeReference: 'window',
    responsiveEffect: 'easeInQuad',
    dropdownLabelTpl: '<a href="javascript:void(0)"></a>',
    responsiveDuration: 300,

    // callback
    onReady: null
  };

  var dependencies = ['Hammer', 'anime'];

  var info = { version: '0.2.1' };

  var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var anime_min = createCommonjsModule(function (module) {
  /*
   2017 Julian Garnier
   Released under the MIT license
  */
  var $jscomp={scope:{}};$jscomp.defineProperty="function"==typeof Object.defineProperties?Object.defineProperty:function(e,r,p){if(p.get||p.set)throw new TypeError("ES3 does not support getters and setters.");e!=Array.prototype&&e!=Object.prototype&&(e[r]=p.value);};$jscomp.getGlobal=function(e){return"undefined"!=typeof window&&window===e?e:"undefined"!=typeof commonjsGlobal&&null!=commonjsGlobal?commonjsGlobal:e};$jscomp.global=$jscomp.getGlobal(commonjsGlobal);$jscomp.SYMBOL_PREFIX="jscomp_symbol_";
  $jscomp.initSymbol=function(){$jscomp.initSymbol=function(){};$jscomp.global.Symbol||($jscomp.global.Symbol=$jscomp.Symbol);};$jscomp.symbolCounter_=0;$jscomp.Symbol=function(e){return $jscomp.SYMBOL_PREFIX+(e||"")+$jscomp.symbolCounter_++};
  $jscomp.initSymbolIterator=function(){$jscomp.initSymbol();var e=$jscomp.global.Symbol.iterator;e||(e=$jscomp.global.Symbol.iterator=$jscomp.global.Symbol("iterator"));"function"!=typeof Array.prototype[e]&&$jscomp.defineProperty(Array.prototype,e,{configurable:!0,writable:!0,value:function(){return $jscomp.arrayIterator(this)}});$jscomp.initSymbolIterator=function(){};};$jscomp.arrayIterator=function(e){var r=0;return $jscomp.iteratorPrototype(function(){return r<e.length?{done:!1,value:e[r++]}:{done:!0}})};
  $jscomp.iteratorPrototype=function(e){$jscomp.initSymbolIterator();e={next:e};e[$jscomp.global.Symbol.iterator]=function(){return this};return e};$jscomp.array=$jscomp.array||{};$jscomp.iteratorFromArray=function(e,r){$jscomp.initSymbolIterator();e instanceof String&&(e+="");var p=0,m={next:function(){if(p<e.length){var u=p++;return{value:r(u,e[u]),done:!1}}m.next=function(){return{done:!0,value:void 0}};return m.next()}};m[Symbol.iterator]=function(){return m};return m};
  $jscomp.polyfill=function(e,r,p,m){if(r){p=$jscomp.global;e=e.split(".");for(m=0;m<e.length-1;m++){var u=e[m];u in p||(p[u]={});p=p[u];}e=e[e.length-1];m=p[e];r=r(m);r!=m&&null!=r&&$jscomp.defineProperty(p,e,{configurable:!0,writable:!0,value:r});}};$jscomp.polyfill("Array.prototype.keys",function(e){return e?e:function(){return $jscomp.iteratorFromArray(this,function(e){return e})}},"es6-impl","es3");var $jscomp$this=commonjsGlobal;
  (function(e,r){"function"===typeof undefined&&undefined.amd?undefined([],r):"object"==='object'&&module.exports?module.exports=r():e.anime=r();})(commonjsGlobal,function(){function e(a){if(!h.col(a))try{return document.querySelectorAll(a)}catch(c){}}function r(a,c){for(var d=a.length,b=2<=arguments.length?arguments[1]:void 0,f=[],n=0;n<d;n++)if(n in a){var k=a[n];c.call(b,k,n,a)&&f.push(k);}return f}function p(a){return a.reduce(function(a,d){return a.concat(h.arr(d)?p(d):d)},[])}function m(a){if(h.arr(a))return a;
  h.str(a)&&(a=e(a)||a);return a instanceof NodeList||a instanceof HTMLCollection?[].slice.call(a):[a]}function u(a,c){return a.some(function(a){return a===c})}function C(a){var c={},d;for(d in a)c[d]=a[d];return c}function D(a,c){var d=C(a),b;for(b in a)d[b]=c.hasOwnProperty(b)?c[b]:a[b];return d}function z(a,c){var d=C(a),b;for(b in c)d[b]=h.und(a[b])?c[b]:a[b];return d}function T(a){a=a.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i,function(a,c,d,k){return c+c+d+d+k+k});var c=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(a);
  a=parseInt(c[1],16);var d=parseInt(c[2],16),c=parseInt(c[3],16);return"rgba("+a+","+d+","+c+",1)"}function U(a){function c(a,c,b){0>b&&(b+=1);1<b&&--b;return b<1/6?a+6*(c-a)*b:.5>b?c:b<2/3?a+(c-a)*(2/3-b)*6:a}var d=/hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(a)||/hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(a);a=parseInt(d[1])/360;var b=parseInt(d[2])/100,f=parseInt(d[3])/100,d=d[4]||1;if(0==b)f=b=a=f;else{var n=.5>f?f*(1+b):f+b-f*b,k=2*f-n,f=c(k,n,a+1/3),b=c(k,n,a);a=c(k,n,a-1/3);}return"rgba("+
  255*f+","+255*b+","+255*a+","+d+")"}function y(a){if(a=/([\+\-]?[0-9#\.]+)(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(a))return a[2]}function V(a){if(-1<a.indexOf("translate")||"perspective"===a)return"px";if(-1<a.indexOf("rotate")||-1<a.indexOf("skew"))return"deg"}function I(a,c){return h.fnc(a)?a(c.target,c.id,c.total):a}function E(a,c){if(c in a.style)return getComputedStyle(a).getPropertyValue(c.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase())||"0"}function J(a,c){if(h.dom(a)&&
  u(W,c))return"transform";if(h.dom(a)&&(a.getAttribute(c)||h.svg(a)&&a[c]))return"attribute";if(h.dom(a)&&"transform"!==c&&E(a,c))return"css";if(null!=a[c])return"object"}function X(a,c){var d=V(c),d=-1<c.indexOf("scale")?1:0+d;a=a.style.transform;if(!a)return d;for(var b=[],f=[],n=[],k=/(\w+)\((.+?)\)/g;b=k.exec(a);)f.push(b[1]), n.push(b[2]);a=r(n,function(a,b){return f[b]===c});return a.length?a[0]:d}function K(a,c){switch(J(a,c)){case "transform":return X(a,c);case "css":return E(a,c);case "attribute":return a.getAttribute(c)}return a[c]||
  0}function L(a,c){var d=/^(\*=|\+=|-=)/.exec(a);if(!d)return a;var b=y(a)||0;c=parseFloat(c);a=parseFloat(a.replace(d[0],""));switch(d[0][0]){case "+":return c+a+b;case "-":return c-a+b;case "*":return c*a+b}}function F(a,c){return Math.sqrt(Math.pow(c.x-a.x,2)+Math.pow(c.y-a.y,2))}function M(a){a=a.points;for(var c=0,d,b=0;b<a.numberOfItems;b++){var f=a.getItem(b);0<b&&(c+=F(d,f));d=f;}return c}function N(a){if(a.getTotalLength)return a.getTotalLength();switch(a.tagName.toLowerCase()){case "circle":return 2*
  Math.PI*a.getAttribute("r");case "rect":return 2*a.getAttribute("width")+2*a.getAttribute("height");case "line":return F({x:a.getAttribute("x1"),y:a.getAttribute("y1")},{x:a.getAttribute("x2"),y:a.getAttribute("y2")});case "polyline":return M(a);case "polygon":var c=a.points;return M(a)+F(c.getItem(c.numberOfItems-1),c.getItem(0))}}function Y(a,c){function d(b){b=void 0===b?0:b;return a.el.getPointAtLength(1<=c+b?c+b:0)}var b=d(),f=d(-1),n=d(1);switch(a.property){case "x":return b.x;case "y":return b.y;
  case "angle":return 180*Math.atan2(n.y-f.y,n.x-f.x)/Math.PI}}function O(a,c){var d=/-?\d*\.?\d+/g,b;b=h.pth(a)?a.totalLength:a;if(h.col(b))if(h.rgb(b)){var f=/rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(b);b=f?"rgba("+f[1]+",1)":b;}else b=h.hex(b)?T(b):h.hsl(b)?U(b):void 0;else f=(f=y(b))?b.substr(0,b.length-f.length):b, b=c&&!/\s/g.test(b)?f+c:f;b+="";return{original:b,numbers:b.match(d)?b.match(d).map(Number):[0],strings:h.str(a)||c?b.split(d):[]}}function P(a){a=a?p(h.arr(a)?a.map(m):m(a)):[];return r(a,
  function(a,d,b){return b.indexOf(a)===d})}function Z(a){var c=P(a);return c.map(function(a,b){return{target:a,id:b,total:c.length}})}function aa(a,c){var d=C(c);if(h.arr(a)){var b=a.length;2!==b||h.obj(a[0])?h.fnc(c.duration)||(d.duration=c.duration/b):a={value:a};}return m(a).map(function(a,b){b=b?0:c.delay;a=h.obj(a)&&!h.pth(a)?a:{value:a};h.und(a.delay)&&(a.delay=b);return a}).map(function(a){return z(a,d)})}function ba(a,c){var d={},b;for(b in a){var f=I(a[b],c);h.arr(f)&&(f=f.map(function(a){return I(a,
  c)}), 1===f.length&&(f=f[0]));d[b]=f;}d.duration=parseFloat(d.duration);d.delay=parseFloat(d.delay);return d}function ca(a){return h.arr(a)?A.apply(this,a):Q[a]}function da(a,c){var d;return a.tweens.map(function(b){b=ba(b,c);var f=b.value,e=K(c.target,a.name),k=d?d.to.original:e,k=h.arr(f)?f[0]:k,w=L(h.arr(f)?f[1]:f,k),e=y(w)||y(k)||y(e);b.from=O(k,e);b.to=O(w,e);b.start=d?d.end:a.offset;b.end=b.start+b.delay+b.duration;b.easing=ca(b.easing);b.elasticity=(1E3-Math.min(Math.max(b.elasticity,1),999))/
  1E3;b.isPath=h.pth(f);b.isColor=h.col(b.from.original);b.isColor&&(b.round=1);return d=b})}function ea(a,c){return r(p(a.map(function(a){return c.map(function(b){var c=J(a.target,b.name);if(c){var d=da(b,a);b={type:c,property:b.name,animatable:a,tweens:d,duration:d[d.length-1].end,delay:d[0].delay};}else b=void 0;return b})})),function(a){return!h.und(a)})}function R(a,c,d,b){var f="delay"===a;return c.length?(f?Math.min:Math.max).apply(Math,c.map(function(b){return b[a]})):f?b.delay:d.offset+b.delay+
  b.duration}function fa(a){var c=D(ga,a),d=D(S,a),b=Z(a.targets),f=[],e=z(c,d),k;for(k in a)e.hasOwnProperty(k)||"targets"===k||f.push({name:k,offset:e.offset,tweens:aa(a[k],d)});a=ea(b,f);return z(c,{children:[],animatables:b,animations:a,duration:R("duration",a,c,d),delay:R("delay",a,c,d)})}function q(a){function c(){return window.Promise&&new Promise(function(a){return p=a})}function d(a){return g.reversed?g.duration-a:a}function b(a){for(var b=0,c={},d=g.animations,f=d.length;b<f;){var e=d[b],
  k=e.animatable,h=e.tweens,n=h.length-1,l=h[n];n&&(l=r(h,function(b){return a<b.end})[0]||l);for(var h=Math.min(Math.max(a-l.start-l.delay,0),l.duration)/l.duration,w=isNaN(h)?1:l.easing(h,l.elasticity),h=l.to.strings,p=l.round,n=[],m=void 0,m=l.to.numbers.length,t=0;t<m;t++){var x=void 0,x=l.to.numbers[t],q=l.from.numbers[t],x=l.isPath?Y(l.value,w*x):q+w*(x-q);p&&(l.isColor&&2<t||(x=Math.round(x*p)/p));n.push(x);}if(l=h.length)for(m=h[0], w=0;w<l;w++)p=h[w+1], t=n[w], isNaN(t)||(m=p?m+(t+p):m+(t+" "));
  else m=n[0];ha[e.type](k.target,e.property,m,c,k.id);e.currentValue=m;b++;}if(b=Object.keys(c).length)for(d=0;d<b;d++)H||(H=E(document.body,"transform")?"transform":"-webkit-transform"), g.animatables[d].target.style[H]=c[d].join(" ");g.currentTime=a;g.progress=a/g.duration*100;}function f(a){if(g[a])g[a](g);}function e(){g.remaining&&!0!==g.remaining&&g.remaining--;}function k(a){var k=g.duration,n=g.offset,w=n+g.delay,r=g.currentTime,x=g.reversed,q=d(a);if(g.children.length){var u=g.children,v=u.length;
  if(q>=g.currentTime)for(var G=0;G<v;G++)u[G].seek(q);else for(;v--;)u[v].seek(q);}if(q>=w||!k)g.began||(g.began=!0, f("begin")), f("run");if(q>n&&q<k)b(q);else if(q<=n&&0!==r&&(b(0), x&&e()), q>=k&&r!==k||!k)b(k), x||e();f("update");a>=k&&(g.remaining?(t=h, "alternate"===g.direction&&(g.reversed=!g.reversed)):(g.pause(), g.completed||(g.completed=!0, f("complete"), "Promise"in window&&(p(), m=c()))), l=0);}a=void 0===a?{}:a;var h,t,l=0,p=null,m=c(),g=fa(a);g.reset=function(){var a=g.direction,c=g.loop;g.currentTime=
  0;g.progress=0;g.paused=!0;g.began=!1;g.completed=!1;g.reversed="reverse"===a;g.remaining="alternate"===a&&1===c?2:c;b(0);for(a=g.children.length;a--;)g.children[a].reset();};g.tick=function(a){h=a;t||(t=h);k((l+h-t)*q.speed);};g.seek=function(a){k(d(a));};g.pause=function(){var a=v.indexOf(g);-1<a&&v.splice(a,1);g.paused=!0;};g.play=function(){g.paused&&(g.paused=!1, t=0, l=d(g.currentTime), v.push(g), B||ia());};g.reverse=function(){g.reversed=!g.reversed;t=0;l=d(g.currentTime);};g.restart=function(){g.pause();
  g.reset();g.play();};g.finished=m;g.reset();g.autoplay&&g.play();return g}var ga={update:void 0,begin:void 0,run:void 0,complete:void 0,loop:1,direction:"normal",autoplay:!0,offset:0},S={duration:1E3,delay:0,easing:"easeOutElastic",elasticity:500,round:0},W="translateX translateY translateZ rotate rotateX rotateY rotateZ scale scaleX scaleY scaleZ skewX skewY perspective".split(" "),H,h={arr:function(a){return Array.isArray(a)},obj:function(a){return-1<Object.prototype.toString.call(a).indexOf("Object")},
  pth:function(a){return h.obj(a)&&a.hasOwnProperty("totalLength")},svg:function(a){return a instanceof SVGElement},dom:function(a){return a.nodeType||h.svg(a)},str:function(a){return"string"===typeof a},fnc:function(a){return"function"===typeof a},und:function(a){return"undefined"===typeof a},hex:function(a){return/(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a)},rgb:function(a){return/^rgb/.test(a)},hsl:function(a){return/^hsl/.test(a)},col:function(a){return h.hex(a)||h.rgb(a)||h.hsl(a)}},A=function(){function a(a,
  d,b){return(((1-3*b+3*d)*a+(3*b-6*d))*a+3*d)*a}return function(c,d,b,f){if(0<=c&&1>=c&&0<=b&&1>=b){var e=new Float32Array(11);if(c!==d||b!==f)for(var k=0;11>k;++k)e[k]=a(.1*k,c,b);return function(k){if(c===d&&b===f)return k;if(0===k)return 0;if(1===k)return 1;for(var h=0,l=1;10!==l&&e[l]<=k;++l)h+=.1;--l;var l=h+(k-e[l])/(e[l+1]-e[l])*.1,n=3*(1-3*b+3*c)*l*l+2*(3*b-6*c)*l+3*c;if(.001<=n){for(h=0;4>h;++h){n=3*(1-3*b+3*c)*l*l+2*(3*b-6*c)*l+3*c;if(0===n)break;var m=a(l,c,b)-k,l=l-m/n;}k=l;}else if(0===
  n)k=l;else{var l=h,h=h+.1,g=0;do m=l+(h-l)/2, n=a(m,c,b)-k, 0<n?h=m:l=m;while(1e-7<Math.abs(n)&&10>++g);k=m;}return a(k,d,f)}}}}(),Q=function(){function a(a,b){return 0===a||1===a?a:-Math.pow(2,10*(a-1))*Math.sin(2*(a-1-b/(2*Math.PI)*Math.asin(1))*Math.PI/b)}var c="Quad Cubic Quart Quint Sine Expo Circ Back Elastic".split(" "),d={In:[[.55,.085,.68,.53],[.55,.055,.675,.19],[.895,.03,.685,.22],[.755,.05,.855,.06],[.47,0,.745,.715],[.95,.05,.795,.035],[.6,.04,.98,.335],[.6,-.28,.735,.045],a],Out:[[.25,
  .46,.45,.94],[.215,.61,.355,1],[.165,.84,.44,1],[.23,1,.32,1],[.39,.575,.565,1],[.19,1,.22,1],[.075,.82,.165,1],[.175,.885,.32,1.275],function(b,c){return 1-a(1-b,c)}],InOut:[[.455,.03,.515,.955],[.645,.045,.355,1],[.77,0,.175,1],[.86,0,.07,1],[.445,.05,.55,.95],[1,0,0,1],[.785,.135,.15,.86],[.68,-.55,.265,1.55],function(b,c){return.5>b?a(2*b,c)/2:1-a(-2*b+2,c)/2}]},b={linear:A(.25,.25,.75,.75)},f={},e;for(e in d)f.type=e, d[f.type].forEach(function(a){return function(d,f){b["ease"+a.type+c[f]]=h.fnc(d)?
  d:A.apply($jscomp$this,d);}}(f)), f={type:f.type};return b}(),ha={css:function(a,c,d){return a.style[c]=d},attribute:function(a,c,d){return a.setAttribute(c,d)},object:function(a,c,d){return a[c]=d},transform:function(a,c,d,b,f){b[f]||(b[f]=[]);b[f].push(c+"("+d+")");}},v=[],B=0,ia=function(){function a(){B=requestAnimationFrame(c);}function c(c){var b=v.length;if(b){for(var d=0;d<b;)v[d]&&v[d].tick(c), d++;a();}else cancelAnimationFrame(B), B=0;}return a}();q.version="2.2.0";q.speed=1;q.running=v;q.remove=
  function(a){a=P(a);for(var c=v.length;c--;)for(var d=v[c],b=d.animations,f=b.length;f--;)u(a,b[f].animatable.target)&&(b.splice(f,1), b.length||d.pause());};q.getValue=K;q.path=function(a,c){var d=h.str(a)?e(a)[0]:a,b=c||100;return function(a){return{el:d,property:a,totalLength:N(d)*(b/100)}}};q.setDashoffset=function(a){var c=N(a);a.setAttribute("stroke-dasharray",c);return c};q.bezier=A;q.easings=Q;q.timeline=function(a){var c=q(a);c.pause();c.duration=0;c.add=function(d){c.children.forEach(function(a){a.began=
  !0;a.completed=!0;});m(d).forEach(function(b){var d=z(b,D(S,a||{}));d.targets=d.targets||a.targets;b=c.duration;var e=d.offset;d.autoplay=!1;d.direction=c.direction;d.offset=h.und(e)?b:L(e,b);c.began=!0;c.completed=!0;c.seek(d.offset);d=q(d);d.began=!0;d.completed=!0;d.duration>b&&(c.duration=d.duration);c.children.push(d);});c.seek(0);c.reset();c.autoplay&&c.restart();return c};return c};q.random=function(a,c){return Math.floor(Math.random()*(c-a+1))+a};return q});
  });

  // last:: [a] -> a

  var sum = function sum(arr) {
    return arr.reduce(function (a, b) {
      return a + b;
    });
  };

  /**
   * setStyle({
   *  fontSize: '16px',
   *  display: 'flex'
   * }, element)
   */
  var setStyle = curry(function (style, el) {
    Object.entries(style).forEach(function (_ref) {
      var _ref2 = slicedToArray(_ref, 2),
          k = _ref2[0],
          v = _ref2[1];

      if (typeof v === 'number') {
        v = v.toString() + 'px';
      }
      el.style[k] = v;
    });
    return el;
  });

  var outerHeight = function outerHeight(el) {
    return el.offsetHeight;
  };

  var outerHeightWithMargin = function outerHeightWithMargin(el) {
    var height = outerHeight(el);

    var _window$getComputedSt = window.getComputedStyle(el),
        marginTop = _window$getComputedSt.marginTop,
        marginBottom = _window$getComputedSt.marginBottom;

    return sum([marginTop, marginBottom].map(function (i) {
      return parseInt(i, 10);
    }).concat(height));
  };

  var outerWidth = function outerWidth(el) {
    return el.offsetWidth;
  };

  var outerWidthWithMargin = function outerWidthWithMargin(el) {
    var width = outerWidth(el);

    var _window$getComputedSt2 = window.getComputedStyle(el),
        marginLeft = _window$getComputedSt2.marginLeft,
        marginRight = _window$getComputedSt2.marginRight;

    return sum([marginLeft, marginRight].map(function (i) {
      return parseInt(i, 10);
    }).concat(width));
  };

  var contentWidth = function contentWidth(el) {
    var _window$getComputedSt3 = window.getComputedStyle(el),
        paddingLeft = _window$getComputedSt3.paddingLeft,
        paddingRight = _window$getComputedSt3.paddingRight,
        width = _window$getComputedSt3.width;

    return parseInt(width, 10) - sum([paddingLeft, paddingRight].map(function (i) {
      return parseInt(i, 10);
    }));
  };

  var Animate = function () {
    function Animate(instance) {
      classCallCheck(this, Animate);

      this.instance = instance;
      this.initialize();
    }

    createClass(Animate, [{
      key: 'initialize',
      value: function initialize() {
        var _this = this;

        this.horizontal = this.instance.options.horizontal;
        this.property = this.horizontal ? 'width' : 'height';
        this.initDistance();
        this.instance.$panes.map(setStyle(defineProperty({}, this.property, this.headerDistance + 'px')));
        if (this.horizontal) {
          this.instance.$contentInners.map(setStyle({ width: this.contentDistance[0] + 'px' }));
          this.instance.$contentInners.map(function (item, index) {
            return setStyle({ width: _this.contentDistance[index] + 'px' }, item);
          });
        }
      }
    }, {
      key: 'initDistance',
      value: function initDistance() {
        if (this.horizontal) {
          this.getPaneSpace();
        }

        this.getHeaderDistance();
        this.getContentDistance();
      }
    }, {
      key: 'getPaneSpace',
      value: function getPaneSpace() {
        this.paneSpace = outerWidthWithMargin(this.instance.$panes[1]) - outerWidth(this.instance.$panes[1]);
        return this.paneSpace;
      }
    }, {
      key: 'getHeaderDistance',
      value: function getHeaderDistance() {
        this.headerDistance = outerHeightWithMargin(this.instance.$headers[0]) + 2;
      }
    }, {
      key: 'getContentDistance',
      value: function getContentDistance() {
        var _this2 = this;

        var innerWidth = contentWidth(this.instance.element);
        var size = this.instance.size;
        this.contentDistance = this.instance.$contentInners.map(function (element) {
          if (_this2.horizontal) {
            return innerWidth - size * _this2.headerDistance - (size - 1) * _this2.paneSpace;
          }
          return compose(outerHeight, compose(parentWith, hasClass)(_this2.instance.classes.PANECONTENT))(element);
        });
        return this.contentDistance;
      }
    }, {
      key: 'resetWidth',
      value: function resetWidth() {
        var immediately = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

        if (this.instance.is('built')) {
          return;
        }

        var current = this.instance.current;

        this.getContentDistance();

        if (this.horizontal) {
          this.instance.$contentInners.map(setStyle({ width: this.contentDistance[0] + 'px' }));
        }

        for (var i = 0; i < current.length; i++) {
          var index = current[i];
          var pane = this.instance.$panes[index];
          var opts = {
            targets: pane,
            duration: immediately ? 1 : 200,
            easing: 'linear'
          };

          opts[this.property] = this.headerDistance + this.contentDistance[index];

          anime_min(opts);
        }
      }
    }, {
      key: 'open',
      value: function open(index, trigger) {
        var pane = this.instance.$panes[index];
        var opts = {
          targets: pane,
          duration: trigger ? 200 : 1,
          easing: 'linear'
        };

        opts[this.property] = this.headerDistance + this.contentDistance[index];

        anime_min(opts);
      }
    }, {
      key: 'close',
      value: function close(index, trigger) {
        var pane = this.instance.$panes[index];
        var opts = {
          targets: pane,
          duration: trigger ? 200 : 1,
          easing: 'linear'
        };

        opts[this.property] = this.headerDistance;

        anime_min(opts);
      }
    }]);
    return Animate;
  }();

  var hammer = createCommonjsModule(function (module) {
  /*! Hammer.JS - v2.0.7 - 2016-04-22
   * http://hammerjs.github.io/
   *
   * Copyright (c) 2016 Jorik Tangelder;
   * Licensed under the MIT license */
  (function(window, document, exportName, undefined) {

  var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
  var TEST_ELEMENT = document.createElement('div');

  var TYPE_FUNCTION = 'function';

  var round = Math.round;
  var abs = Math.abs;
  var now = Date.now;

  /**
   * set a timeout with a given scope
   * @param {Function} fn
   * @param {Number} timeout
   * @param {Object} context
   * @returns {number}
   */
  function setTimeoutContext(fn, timeout, context) {
      return setTimeout(bindFn(fn, context), timeout);
  }

  /**
   * if the argument is an array, we want to execute the fn on each entry
   * if it aint an array we don't want to do a thing.
   * this is used by all the methods that accept a single and array argument.
   * @param {*|Array} arg
   * @param {String} fn
   * @param {Object} [context]
   * @returns {Boolean}
   */
  function invokeArrayArg(arg, fn, context) {
      if (Array.isArray(arg)) {
          each(arg, context[fn], context);
          return true;
      }
      return false;
  }

  /**
   * walk objects and arrays
   * @param {Object} obj
   * @param {Function} iterator
   * @param {Object} context
   */
  function each(obj, iterator, context) {
      var i;

      if (!obj) {
          return;
      }

      if (obj.forEach) {
          obj.forEach(iterator, context);
      } else if (obj.length !== undefined) {
          i = 0;
          while (i < obj.length) {
              iterator.call(context, obj[i], i, obj);
              i++;
          }
      } else {
          for (i in obj) {
              obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
          }
      }
  }

  /**
   * wrap a method with a deprecation warning and stack trace
   * @param {Function} method
   * @param {String} name
   * @param {String} message
   * @returns {Function} A new function wrapping the supplied method.
   */
  function deprecate(method, name, message) {
      var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
      return function() {
          var e = new Error('get-stack-trace');
          var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
              .replace(/^\s+at\s+/gm, '')
              .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

          var log = window.console && (window.console.warn || window.console.log);
          if (log) {
              log.call(window.console, deprecationMessage, stack);
          }
          return method.apply(this, arguments);
      };
  }

  /**
   * extend object.
   * means that properties in dest will be overwritten by the ones in src.
   * @param {Object} target
   * @param {...Object} objects_to_assign
   * @returns {Object} target
   */
  var assign;
  if (typeof Object.assign !== 'function') {
      assign = function assign(target) {
          if (target === undefined || target === null) {
              throw new TypeError('Cannot convert undefined or null to object');
          }

          var output = Object(target);
          for (var index = 1; index < arguments.length; index++) {
              var source = arguments[index];
              if (source !== undefined && source !== null) {
                  for (var nextKey in source) {
                      if (source.hasOwnProperty(nextKey)) {
                          output[nextKey] = source[nextKey];
                      }
                  }
              }
          }
          return output;
      };
  } else {
      assign = Object.assign;
  }

  /**
   * extend object.
   * means that properties in dest will be overwritten by the ones in src.
   * @param {Object} dest
   * @param {Object} src
   * @param {Boolean} [merge=false]
   * @returns {Object} dest
   */
  var extend = deprecate(function extend(dest, src, merge) {
      var keys = Object.keys(src);
      var i = 0;
      while (i < keys.length) {
          if (!merge || (merge && dest[keys[i]] === undefined)) {
              dest[keys[i]] = src[keys[i]];
          }
          i++;
      }
      return dest;
  }, 'extend', 'Use `assign`.');

  /**
   * merge the values from src in the dest.
   * means that properties that exist in dest will not be overwritten by src
   * @param {Object} dest
   * @param {Object} src
   * @returns {Object} dest
   */
  var merge = deprecate(function merge(dest, src) {
      return extend(dest, src, true);
  }, 'merge', 'Use `assign`.');

  /**
   * simple class inheritance
   * @param {Function} child
   * @param {Function} base
   * @param {Object} [properties]
   */
  function inherit(child, base, properties) {
      var baseP = base.prototype,
          childP;

      childP = child.prototype = Object.create(baseP);
      childP.constructor = child;
      childP._super = baseP;

      if (properties) {
          assign(childP, properties);
      }
  }

  /**
   * simple function bind
   * @param {Function} fn
   * @param {Object} context
   * @returns {Function}
   */
  function bindFn(fn, context) {
      return function boundFn() {
          return fn.apply(context, arguments);
      };
  }

  /**
   * let a boolean value also be a function that must return a boolean
   * this first item in args will be used as the context
   * @param {Boolean|Function} val
   * @param {Array} [args]
   * @returns {Boolean}
   */
  function boolOrFn(val, args) {
      if (typeof val == TYPE_FUNCTION) {
          return val.apply(args ? args[0] || undefined : undefined, args);
      }
      return val;
  }

  /**
   * use the val2 when val1 is undefined
   * @param {*} val1
   * @param {*} val2
   * @returns {*}
   */
  function ifUndefined(val1, val2) {
      return (val1 === undefined) ? val2 : val1;
  }

  /**
   * addEventListener with multiple events at once
   * @param {EventTarget} target
   * @param {String} types
   * @param {Function} handler
   */
  function addEventListeners(target, types, handler) {
      each(splitStr(types), function(type) {
          target.addEventListener(type, handler, false);
      });
  }

  /**
   * removeEventListener with multiple events at once
   * @param {EventTarget} target
   * @param {String} types
   * @param {Function} handler
   */
  function removeEventListeners(target, types, handler) {
      each(splitStr(types), function(type) {
          target.removeEventListener(type, handler, false);
      });
  }

  /**
   * find if a node is in the given parent
   * @method hasParent
   * @param {HTMLElement} node
   * @param {HTMLElement} parent
   * @return {Boolean} found
   */
  function hasParent(node, parent) {
      while (node) {
          if (node == parent) {
              return true;
          }
          node = node.parentNode;
      }
      return false;
  }

  /**
   * small indexOf wrapper
   * @param {String} str
   * @param {String} find
   * @returns {Boolean} found
   */
  function inStr(str, find) {
      return str.indexOf(find) > -1;
  }

  /**
   * split string on whitespace
   * @param {String} str
   * @returns {Array} words
   */
  function splitStr(str) {
      return str.trim().split(/\s+/g);
  }

  /**
   * find if a array contains the object using indexOf or a simple polyFill
   * @param {Array} src
   * @param {String} find
   * @param {String} [findByKey]
   * @return {Boolean|Number} false when not found, or the index
   */
  function inArray(src, find, findByKey) {
      if (src.indexOf && !findByKey) {
          return src.indexOf(find);
      } else {
          var i = 0;
          while (i < src.length) {
              if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                  return i;
              }
              i++;
          }
          return -1;
      }
  }

  /**
   * convert array-like objects to real arrays
   * @param {Object} obj
   * @returns {Array}
   */
  function toArray(obj) {
      return Array.prototype.slice.call(obj, 0);
  }

  /**
   * unique array with objects based on a key (like 'id') or just by the array's value
   * @param {Array} src [{id:1},{id:2},{id:1}]
   * @param {String} [key]
   * @param {Boolean} [sort=False]
   * @returns {Array} [{id:1},{id:2}]
   */
  function uniqueArray(src, key, sort) {
      var results = [];
      var values = [];
      var i = 0;

      while (i < src.length) {
          var val = key ? src[i][key] : src[i];
          if (inArray(values, val) < 0) {
              results.push(src[i]);
          }
          values[i] = val;
          i++;
      }

      if (sort) {
          if (!key) {
              results = results.sort();
          } else {
              results = results.sort(function sortUniqueArray(a, b) {
                  return a[key] > b[key];
              });
          }
      }

      return results;
  }

  /**
   * get the prefixed property
   * @param {Object} obj
   * @param {String} property
   * @returns {String|Undefined} prefixed
   */
  function prefixed(obj, property) {
      var prefix, prop;
      var camelProp = property[0].toUpperCase() + property.slice(1);

      var i = 0;
      while (i < VENDOR_PREFIXES.length) {
          prefix = VENDOR_PREFIXES[i];
          prop = (prefix) ? prefix + camelProp : property;

          if (prop in obj) {
              return prop;
          }
          i++;
      }
      return undefined;
  }

  /**
   * get a unique id
   * @returns {number} uniqueId
   */
  var _uniqueId = 1;
  function uniqueId() {
      return _uniqueId++;
  }

  /**
   * get the window object of an element
   * @param {HTMLElement} element
   * @returns {DocumentView|Window}
   */
  function getWindowForElement(element) {
      var doc = element.ownerDocument || element;
      return (doc.defaultView || doc.parentWindow || window);
  }

  var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

  var SUPPORT_TOUCH = ('ontouchstart' in window);
  var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
  var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

  var INPUT_TYPE_TOUCH = 'touch';
  var INPUT_TYPE_PEN = 'pen';
  var INPUT_TYPE_MOUSE = 'mouse';
  var INPUT_TYPE_KINECT = 'kinect';

  var COMPUTE_INTERVAL = 25;

  var INPUT_START = 1;
  var INPUT_MOVE = 2;
  var INPUT_END = 4;
  var INPUT_CANCEL = 8;

  var DIRECTION_NONE = 1;
  var DIRECTION_LEFT = 2;
  var DIRECTION_RIGHT = 4;
  var DIRECTION_UP = 8;
  var DIRECTION_DOWN = 16;

  var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
  var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
  var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

  var PROPS_XY = ['x', 'y'];
  var PROPS_CLIENT_XY = ['clientX', 'clientY'];

  /**
   * create new input type manager
   * @param {Manager} manager
   * @param {Function} callback
   * @returns {Input}
   * @constructor
   */
  function Input(manager, callback) {
      var self = this;
      this.manager = manager;
      this.callback = callback;
      this.element = manager.element;
      this.target = manager.options.inputTarget;

      // smaller wrapper around the handler, for the scope and the enabled state of the manager,
      // so when disabled the input events are completely bypassed.
      this.domHandler = function(ev) {
          if (boolOrFn(manager.options.enable, [manager])) {
              self.handler(ev);
          }
      };

      this.init();

  }

  Input.prototype = {
      /**
       * should handle the inputEvent data and trigger the callback
       * @virtual
       */
      handler: function() { },

      /**
       * bind the events
       */
      init: function() {
          this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
      },

      /**
       * unbind the events
       */
      destroy: function() {
          this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
      }
  };

  /**
   * create new input type manager
   * called by the Manager constructor
   * @param {Hammer} manager
   * @returns {Input}
   */
  function createInputInstance(manager) {
      var Type;
      var inputClass = manager.options.inputClass;

      if (inputClass) {
          Type = inputClass;
      } else if (SUPPORT_POINTER_EVENTS) {
          Type = PointerEventInput;
      } else if (SUPPORT_ONLY_TOUCH) {
          Type = TouchInput;
      } else if (!SUPPORT_TOUCH) {
          Type = MouseInput;
      } else {
          Type = TouchMouseInput;
      }
      return new (Type)(manager, inputHandler);
  }

  /**
   * handle input events
   * @param {Manager} manager
   * @param {String} eventType
   * @param {Object} input
   */
  function inputHandler(manager, eventType, input) {
      var pointersLen = input.pointers.length;
      var changedPointersLen = input.changedPointers.length;
      var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
      var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

      input.isFirst = !!isFirst;
      input.isFinal = !!isFinal;

      if (isFirst) {
          manager.session = {};
      }

      // source event is the normalized value of the domEvents
      // like 'touchstart, mouseup, pointerdown'
      input.eventType = eventType;

      // compute scale, rotation etc
      computeInputData(manager, input);

      // emit secret event
      manager.emit('hammer.input', input);

      manager.recognize(input);
      manager.session.prevInput = input;
  }

  /**
   * extend the data with some usable properties like scale, rotate, velocity etc
   * @param {Object} manager
   * @param {Object} input
   */
  function computeInputData(manager, input) {
      var session = manager.session;
      var pointers = input.pointers;
      var pointersLength = pointers.length;

      // store the first input to calculate the distance and direction
      if (!session.firstInput) {
          session.firstInput = simpleCloneInputData(input);
      }

      // to compute scale and rotation we need to store the multiple touches
      if (pointersLength > 1 && !session.firstMultiple) {
          session.firstMultiple = simpleCloneInputData(input);
      } else if (pointersLength === 1) {
          session.firstMultiple = false;
      }

      var firstInput = session.firstInput;
      var firstMultiple = session.firstMultiple;
      var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

      var center = input.center = getCenter(pointers);
      input.timeStamp = now();
      input.deltaTime = input.timeStamp - firstInput.timeStamp;

      input.angle = getAngle(offsetCenter, center);
      input.distance = getDistance(offsetCenter, center);

      computeDeltaXY(session, input);
      input.offsetDirection = getDirection(input.deltaX, input.deltaY);

      var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
      input.overallVelocityX = overallVelocity.x;
      input.overallVelocityY = overallVelocity.y;
      input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

      input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
      input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

      input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
          session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

      computeIntervalInputData(session, input);

      // find the correct target
      var target = manager.element;
      if (hasParent(input.srcEvent.target, target)) {
          target = input.srcEvent.target;
      }
      input.target = target;
  }

  function computeDeltaXY(session, input) {
      var center = input.center;
      var offset = session.offsetDelta || {};
      var prevDelta = session.prevDelta || {};
      var prevInput = session.prevInput || {};

      if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
          prevDelta = session.prevDelta = {
              x: prevInput.deltaX || 0,
              y: prevInput.deltaY || 0
          };

          offset = session.offsetDelta = {
              x: center.x,
              y: center.y
          };
      }

      input.deltaX = prevDelta.x + (center.x - offset.x);
      input.deltaY = prevDelta.y + (center.y - offset.y);
  }

  /**
   * velocity is calculated every x ms
   * @param {Object} session
   * @param {Object} input
   */
  function computeIntervalInputData(session, input) {
      var last = session.lastInterval || input,
          deltaTime = input.timeStamp - last.timeStamp,
          velocity, velocityX, velocityY, direction;

      if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
          var deltaX = input.deltaX - last.deltaX;
          var deltaY = input.deltaY - last.deltaY;

          var v = getVelocity(deltaTime, deltaX, deltaY);
          velocityX = v.x;
          velocityY = v.y;
          velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
          direction = getDirection(deltaX, deltaY);

          session.lastInterval = input;
      } else {
          // use latest velocity info if it doesn't overtake a minimum period
          velocity = last.velocity;
          velocityX = last.velocityX;
          velocityY = last.velocityY;
          direction = last.direction;
      }

      input.velocity = velocity;
      input.velocityX = velocityX;
      input.velocityY = velocityY;
      input.direction = direction;
  }

  /**
   * create a simple clone from the input used for storage of firstInput and firstMultiple
   * @param {Object} input
   * @returns {Object} clonedInputData
   */
  function simpleCloneInputData(input) {
      // make a simple copy of the pointers because we will get a reference if we don't
      // we only need clientXY for the calculations
      var pointers = [];
      var i = 0;
      while (i < input.pointers.length) {
          pointers[i] = {
              clientX: round(input.pointers[i].clientX),
              clientY: round(input.pointers[i].clientY)
          };
          i++;
      }

      return {
          timeStamp: now(),
          pointers: pointers,
          center: getCenter(pointers),
          deltaX: input.deltaX,
          deltaY: input.deltaY
      };
  }

  /**
   * get the center of all the pointers
   * @param {Array} pointers
   * @return {Object} center contains `x` and `y` properties
   */
  function getCenter(pointers) {
      var pointersLength = pointers.length;

      // no need to loop when only one touch
      if (pointersLength === 1) {
          return {
              x: round(pointers[0].clientX),
              y: round(pointers[0].clientY)
          };
      }

      var x = 0, y = 0, i = 0;
      while (i < pointersLength) {
          x += pointers[i].clientX;
          y += pointers[i].clientY;
          i++;
      }

      return {
          x: round(x / pointersLength),
          y: round(y / pointersLength)
      };
  }

  /**
   * calculate the velocity between two points. unit is in px per ms.
   * @param {Number} deltaTime
   * @param {Number} x
   * @param {Number} y
   * @return {Object} velocity `x` and `y`
   */
  function getVelocity(deltaTime, x, y) {
      return {
          x: x / deltaTime || 0,
          y: y / deltaTime || 0
      };
  }

  /**
   * get the direction between two points
   * @param {Number} x
   * @param {Number} y
   * @return {Number} direction
   */
  function getDirection(x, y) {
      if (x === y) {
          return DIRECTION_NONE;
      }

      if (abs(x) >= abs(y)) {
          return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
      }
      return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
  }

  /**
   * calculate the absolute distance between two points
   * @param {Object} p1 {x, y}
   * @param {Object} p2 {x, y}
   * @param {Array} [props] containing x and y keys
   * @return {Number} distance
   */
  function getDistance(p1, p2, props) {
      if (!props) {
          props = PROPS_XY;
      }
      var x = p2[props[0]] - p1[props[0]],
          y = p2[props[1]] - p1[props[1]];

      return Math.sqrt((x * x) + (y * y));
  }

  /**
   * calculate the angle between two coordinates
   * @param {Object} p1
   * @param {Object} p2
   * @param {Array} [props] containing x and y keys
   * @return {Number} angle
   */
  function getAngle(p1, p2, props) {
      if (!props) {
          props = PROPS_XY;
      }
      var x = p2[props[0]] - p1[props[0]],
          y = p2[props[1]] - p1[props[1]];
      return Math.atan2(y, x) * 180 / Math.PI;
  }

  /**
   * calculate the rotation degrees between two pointersets
   * @param {Array} start array of pointers
   * @param {Array} end array of pointers
   * @return {Number} rotation
   */
  function getRotation(start, end) {
      return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
  }

  /**
   * calculate the scale factor between two pointersets
   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
   * @param {Array} start array of pointers
   * @param {Array} end array of pointers
   * @return {Number} scale
   */
  function getScale(start, end) {
      return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
  }

  var MOUSE_INPUT_MAP = {
      mousedown: INPUT_START,
      mousemove: INPUT_MOVE,
      mouseup: INPUT_END
  };

  var MOUSE_ELEMENT_EVENTS = 'mousedown';
  var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

  /**
   * Mouse events input
   * @constructor
   * @extends Input
   */
  function MouseInput() {
      this.evEl = MOUSE_ELEMENT_EVENTS;
      this.evWin = MOUSE_WINDOW_EVENTS;

      this.pressed = false; // mousedown state

      Input.apply(this, arguments);
  }

  inherit(MouseInput, Input, {
      /**
       * handle mouse events
       * @param {Object} ev
       */
      handler: function MEhandler(ev) {
          var eventType = MOUSE_INPUT_MAP[ev.type];

          // on start we want to have the left mouse button down
          if (eventType & INPUT_START && ev.button === 0) {
              this.pressed = true;
          }

          if (eventType & INPUT_MOVE && ev.which !== 1) {
              eventType = INPUT_END;
          }

          // mouse must be down
          if (!this.pressed) {
              return;
          }

          if (eventType & INPUT_END) {
              this.pressed = false;
          }

          this.callback(this.manager, eventType, {
              pointers: [ev],
              changedPointers: [ev],
              pointerType: INPUT_TYPE_MOUSE,
              srcEvent: ev
          });
      }
  });

  var POINTER_INPUT_MAP = {
      pointerdown: INPUT_START,
      pointermove: INPUT_MOVE,
      pointerup: INPUT_END,
      pointercancel: INPUT_CANCEL,
      pointerout: INPUT_CANCEL
  };

  // in IE10 the pointer types is defined as an enum
  var IE10_POINTER_TYPE_ENUM = {
      2: INPUT_TYPE_TOUCH,
      3: INPUT_TYPE_PEN,
      4: INPUT_TYPE_MOUSE,
      5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
  };

  var POINTER_ELEMENT_EVENTS = 'pointerdown';
  var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

  // IE10 has prefixed support, and case-sensitive
  if (window.MSPointerEvent && !window.PointerEvent) {
      POINTER_ELEMENT_EVENTS = 'MSPointerDown';
      POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
  }

  /**
   * Pointer events input
   * @constructor
   * @extends Input
   */
  function PointerEventInput() {
      this.evEl = POINTER_ELEMENT_EVENTS;
      this.evWin = POINTER_WINDOW_EVENTS;

      Input.apply(this, arguments);

      this.store = (this.manager.session.pointerEvents = []);
  }

  inherit(PointerEventInput, Input, {
      /**
       * handle mouse events
       * @param {Object} ev
       */
      handler: function PEhandler(ev) {
          var store = this.store;
          var removePointer = false;

          var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
          var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
          var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

          var isTouch = (pointerType == INPUT_TYPE_TOUCH);

          // get index of the event in the store
          var storeIndex = inArray(store, ev.pointerId, 'pointerId');

          // start and mouse must be down
          if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
              if (storeIndex < 0) {
                  store.push(ev);
                  storeIndex = store.length - 1;
              }
          } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
              removePointer = true;
          }

          // it not found, so the pointer hasn't been down (so it's probably a hover)
          if (storeIndex < 0) {
              return;
          }

          // update the event in the store
          store[storeIndex] = ev;

          this.callback(this.manager, eventType, {
              pointers: store,
              changedPointers: [ev],
              pointerType: pointerType,
              srcEvent: ev
          });

          if (removePointer) {
              // remove from the store
              store.splice(storeIndex, 1);
          }
      }
  });

  var SINGLE_TOUCH_INPUT_MAP = {
      touchstart: INPUT_START,
      touchmove: INPUT_MOVE,
      touchend: INPUT_END,
      touchcancel: INPUT_CANCEL
  };

  var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
  var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

  /**
   * Touch events input
   * @constructor
   * @extends Input
   */
  function SingleTouchInput() {
      this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
      this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
      this.started = false;

      Input.apply(this, arguments);
  }

  inherit(SingleTouchInput, Input, {
      handler: function TEhandler(ev) {
          var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

          // should we handle the touch events?
          if (type === INPUT_START) {
              this.started = true;
          }

          if (!this.started) {
              return;
          }

          var touches = normalizeSingleTouches.call(this, ev, type);

          // when done, reset the started state
          if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
              this.started = false;
          }

          this.callback(this.manager, type, {
              pointers: touches[0],
              changedPointers: touches[1],
              pointerType: INPUT_TYPE_TOUCH,
              srcEvent: ev
          });
      }
  });

  /**
   * @this {TouchInput}
   * @param {Object} ev
   * @param {Number} type flag
   * @returns {undefined|Array} [all, changed]
   */
  function normalizeSingleTouches(ev, type) {
      var all = toArray(ev.touches);
      var changed = toArray(ev.changedTouches);

      if (type & (INPUT_END | INPUT_CANCEL)) {
          all = uniqueArray(all.concat(changed), 'identifier', true);
      }

      return [all, changed];
  }

  var TOUCH_INPUT_MAP = {
      touchstart: INPUT_START,
      touchmove: INPUT_MOVE,
      touchend: INPUT_END,
      touchcancel: INPUT_CANCEL
  };

  var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

  /**
   * Multi-user touch events input
   * @constructor
   * @extends Input
   */
  function TouchInput() {
      this.evTarget = TOUCH_TARGET_EVENTS;
      this.targetIds = {};

      Input.apply(this, arguments);
  }

  inherit(TouchInput, Input, {
      handler: function MTEhandler(ev) {
          var type = TOUCH_INPUT_MAP[ev.type];
          var touches = getTouches.call(this, ev, type);
          if (!touches) {
              return;
          }

          this.callback(this.manager, type, {
              pointers: touches[0],
              changedPointers: touches[1],
              pointerType: INPUT_TYPE_TOUCH,
              srcEvent: ev
          });
      }
  });

  /**
   * @this {TouchInput}
   * @param {Object} ev
   * @param {Number} type flag
   * @returns {undefined|Array} [all, changed]
   */
  function getTouches(ev, type) {
      var allTouches = toArray(ev.touches);
      var targetIds = this.targetIds;

      // when there is only one touch, the process can be simplified
      if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
          targetIds[allTouches[0].identifier] = true;
          return [allTouches, allTouches];
      }

      var i,
          targetTouches,
          changedTouches = toArray(ev.changedTouches),
          changedTargetTouches = [],
          target = this.target;

      // get target touches from touches
      targetTouches = allTouches.filter(function(touch) {
          return hasParent(touch.target, target);
      });

      // collect touches
      if (type === INPUT_START) {
          i = 0;
          while (i < targetTouches.length) {
              targetIds[targetTouches[i].identifier] = true;
              i++;
          }
      }

      // filter changed touches to only contain touches that exist in the collected target ids
      i = 0;
      while (i < changedTouches.length) {
          if (targetIds[changedTouches[i].identifier]) {
              changedTargetTouches.push(changedTouches[i]);
          }

          // cleanup removed touches
          if (type & (INPUT_END | INPUT_CANCEL)) {
              delete targetIds[changedTouches[i].identifier];
          }
          i++;
      }

      if (!changedTargetTouches.length) {
          return;
      }

      return [
          // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
          uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
          changedTargetTouches
      ];
  }

  /**
   * Combined touch and mouse input
   *
   * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
   * This because touch devices also emit mouse events while doing a touch.
   *
   * @constructor
   * @extends Input
   */

  var DEDUP_TIMEOUT = 2500;
  var DEDUP_DISTANCE = 25;

  function TouchMouseInput() {
      Input.apply(this, arguments);

      var handler = bindFn(this.handler, this);
      this.touch = new TouchInput(this.manager, handler);
      this.mouse = new MouseInput(this.manager, handler);

      this.primaryTouch = null;
      this.lastTouches = [];
  }

  inherit(TouchMouseInput, Input, {
      /**
       * handle mouse and touch events
       * @param {Hammer} manager
       * @param {String} inputEvent
       * @param {Object} inputData
       */
      handler: function TMEhandler(manager, inputEvent, inputData) {
          var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
              isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

          if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
              return;
          }

          // when we're in a touch event, record touches to  de-dupe synthetic mouse event
          if (isTouch) {
              recordTouches.call(this, inputEvent, inputData);
          } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
              return;
          }

          this.callback(manager, inputEvent, inputData);
      },

      /**
       * remove the event listeners
       */
      destroy: function destroy() {
          this.touch.destroy();
          this.mouse.destroy();
      }
  });

  function recordTouches(eventType, eventData) {
      if (eventType & INPUT_START) {
          this.primaryTouch = eventData.changedPointers[0].identifier;
          setLastTouch.call(this, eventData);
      } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
          setLastTouch.call(this, eventData);
      }
  }

  function setLastTouch(eventData) {
      var touch = eventData.changedPointers[0];

      if (touch.identifier === this.primaryTouch) {
          var lastTouch = {x: touch.clientX, y: touch.clientY};
          this.lastTouches.push(lastTouch);
          var lts = this.lastTouches;
          var removeLastTouch = function() {
              var i = lts.indexOf(lastTouch);
              if (i > -1) {
                  lts.splice(i, 1);
              }
          };
          setTimeout(removeLastTouch, DEDUP_TIMEOUT);
      }
  }

  function isSyntheticEvent(eventData) {
      var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
      for (var i = 0; i < this.lastTouches.length; i++) {
          var t = this.lastTouches[i];
          var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
          if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
              return true;
          }
      }
      return false;
  }

  var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
  var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

  // magical touchAction value
  var TOUCH_ACTION_COMPUTE = 'compute';
  var TOUCH_ACTION_AUTO = 'auto';
  var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
  var TOUCH_ACTION_NONE = 'none';
  var TOUCH_ACTION_PAN_X = 'pan-x';
  var TOUCH_ACTION_PAN_Y = 'pan-y';
  var TOUCH_ACTION_MAP = getTouchActionProps();

  /**
   * Touch Action
   * sets the touchAction property or uses the js alternative
   * @param {Manager} manager
   * @param {String} value
   * @constructor
   */
  function TouchAction(manager, value) {
      this.manager = manager;
      this.set(value);
  }

  TouchAction.prototype = {
      /**
       * set the touchAction value on the element or enable the polyfill
       * @param {String} value
       */
      set: function(value) {
          // find out the touch-action by the event handlers
          if (value == TOUCH_ACTION_COMPUTE) {
              value = this.compute();
          }

          if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
              this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
          }
          this.actions = value.toLowerCase().trim();
      },

      /**
       * just re-set the touchAction value
       */
      update: function() {
          this.set(this.manager.options.touchAction);
      },

      /**
       * compute the value for the touchAction property based on the recognizer's settings
       * @returns {String} value
       */
      compute: function() {
          var actions = [];
          each(this.manager.recognizers, function(recognizer) {
              if (boolOrFn(recognizer.options.enable, [recognizer])) {
                  actions = actions.concat(recognizer.getTouchAction());
              }
          });
          return cleanTouchActions(actions.join(' '));
      },

      /**
       * this method is called on each input cycle and provides the preventing of the browser behavior
       * @param {Object} input
       */
      preventDefaults: function(input) {
          var srcEvent = input.srcEvent;
          var direction = input.offsetDirection;

          // if the touch action did prevented once this session
          if (this.manager.session.prevented) {
              srcEvent.preventDefault();
              return;
          }

          var actions = this.actions;
          var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
          var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
          var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

          if (hasNone) {
              //do not prevent defaults if this is a tap gesture

              var isTapPointer = input.pointers.length === 1;
              var isTapMovement = input.distance < 2;
              var isTapTouchTime = input.deltaTime < 250;

              if (isTapPointer && isTapMovement && isTapTouchTime) {
                  return;
              }
          }

          if (hasPanX && hasPanY) {
              // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
              return;
          }

          if (hasNone ||
              (hasPanY && direction & DIRECTION_HORIZONTAL) ||
              (hasPanX && direction & DIRECTION_VERTICAL)) {
              return this.preventSrc(srcEvent);
          }
      },

      /**
       * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
       * @param {Object} srcEvent
       */
      preventSrc: function(srcEvent) {
          this.manager.session.prevented = true;
          srcEvent.preventDefault();
      }
  };

  /**
   * when the touchActions are collected they are not a valid value, so we need to clean things up. *
   * @param {String} actions
   * @returns {*}
   */
  function cleanTouchActions(actions) {
      // none
      if (inStr(actions, TOUCH_ACTION_NONE)) {
          return TOUCH_ACTION_NONE;
      }

      var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
      var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

      // if both pan-x and pan-y are set (different recognizers
      // for different directions, e.g. horizontal pan but vertical swipe?)
      // we need none (as otherwise with pan-x pan-y combined none of these
      // recognizers will work, since the browser would handle all panning
      if (hasPanX && hasPanY) {
          return TOUCH_ACTION_NONE;
      }

      // pan-x OR pan-y
      if (hasPanX || hasPanY) {
          return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
      }

      // manipulation
      if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
          return TOUCH_ACTION_MANIPULATION;
      }

      return TOUCH_ACTION_AUTO;
  }

  function getTouchActionProps() {
      if (!NATIVE_TOUCH_ACTION) {
          return false;
      }
      var touchMap = {};
      var cssSupports = window.CSS && window.CSS.supports;
      ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {

          // If css.supports is not supported but there is native touch-action assume it supports
          // all values. This is the case for IE 10 and 11.
          touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
      });
      return touchMap;
  }

  /**
   * Recognizer flow explained; *
   * All recognizers have the initial state of POSSIBLE when a input session starts.
   * The definition of a input session is from the first input until the last input, with all it's movement in it. *
   * Example session for mouse-input: mousedown -> mousemove -> mouseup
   *
   * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
   * which determines with state it should be.
   *
   * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
   * POSSIBLE to give it another change on the next cycle.
   *
   *               Possible
   *                  |
   *            +-----+---------------+
   *            |                     |
   *      +-----+-----+               |
   *      |           |               |
   *   Failed      Cancelled          |
   *                          +-------+------+
   *                          |              |
   *                      Recognized       Began
   *                                         |
   *                                      Changed
   *                                         |
   *                                  Ended/Recognized
   */
  var STATE_POSSIBLE = 1;
  var STATE_BEGAN = 2;
  var STATE_CHANGED = 4;
  var STATE_ENDED = 8;
  var STATE_RECOGNIZED = STATE_ENDED;
  var STATE_CANCELLED = 16;
  var STATE_FAILED = 32;

  /**
   * Recognizer
   * Every recognizer needs to extend from this class.
   * @constructor
   * @param {Object} options
   */
  function Recognizer(options) {
      this.options = assign({}, this.defaults, options || {});

      this.id = uniqueId();

      this.manager = null;

      // default is enable true
      this.options.enable = ifUndefined(this.options.enable, true);

      this.state = STATE_POSSIBLE;

      this.simultaneous = {};
      this.requireFail = [];
  }

  Recognizer.prototype = {
      /**
       * @virtual
       * @type {Object}
       */
      defaults: {},

      /**
       * set options
       * @param {Object} options
       * @return {Recognizer}
       */
      set: function(options) {
          assign(this.options, options);

          // also update the touchAction, in case something changed about the directions/enabled state
          this.manager && this.manager.touchAction.update();
          return this;
      },

      /**
       * recognize simultaneous with an other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      recognizeWith: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
              return this;
          }

          var simultaneous = this.simultaneous;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (!simultaneous[otherRecognizer.id]) {
              simultaneous[otherRecognizer.id] = otherRecognizer;
              otherRecognizer.recognizeWith(this);
          }
          return this;
      },

      /**
       * drop the simultaneous link. it doesnt remove the link on the other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      dropRecognizeWith: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
              return this;
          }

          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          delete this.simultaneous[otherRecognizer.id];
          return this;
      },

      /**
       * recognizer can only run when an other is failing
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      requireFailure: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
              return this;
          }

          var requireFail = this.requireFail;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (inArray(requireFail, otherRecognizer) === -1) {
              requireFail.push(otherRecognizer);
              otherRecognizer.requireFailure(this);
          }
          return this;
      },

      /**
       * drop the requireFailure link. it does not remove the link on the other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      dropRequireFailure: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
              return this;
          }

          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          var index = inArray(this.requireFail, otherRecognizer);
          if (index > -1) {
              this.requireFail.splice(index, 1);
          }
          return this;
      },

      /**
       * has require failures boolean
       * @returns {boolean}
       */
      hasRequireFailures: function() {
          return this.requireFail.length > 0;
      },

      /**
       * if the recognizer can recognize simultaneous with an other recognizer
       * @param {Recognizer} otherRecognizer
       * @returns {Boolean}
       */
      canRecognizeWith: function(otherRecognizer) {
          return !!this.simultaneous[otherRecognizer.id];
      },

      /**
       * You should use `tryEmit` instead of `emit` directly to check
       * that all the needed recognizers has failed before emitting.
       * @param {Object} input
       */
      emit: function(input) {
          var self = this;
          var state = this.state;

          function emit(event) {
              self.manager.emit(event, input);
          }

          // 'panstart' and 'panmove'
          if (state < STATE_ENDED) {
              emit(self.options.event + stateStr(state));
          }

          emit(self.options.event); // simple 'eventName' events

          if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
              emit(input.additionalEvent);
          }

          // panend and pancancel
          if (state >= STATE_ENDED) {
              emit(self.options.event + stateStr(state));
          }
      },

      /**
       * Check that all the require failure recognizers has failed,
       * if true, it emits a gesture event,
       * otherwise, setup the state to FAILED.
       * @param {Object} input
       */
      tryEmit: function(input) {
          if (this.canEmit()) {
              return this.emit(input);
          }
          // it's failing anyway
          this.state = STATE_FAILED;
      },

      /**
       * can we emit?
       * @returns {boolean}
       */
      canEmit: function() {
          var i = 0;
          while (i < this.requireFail.length) {
              if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                  return false;
              }
              i++;
          }
          return true;
      },

      /**
       * update the recognizer
       * @param {Object} inputData
       */
      recognize: function(inputData) {
          // make a new copy of the inputData
          // so we can change the inputData without messing up the other recognizers
          var inputDataClone = assign({}, inputData);

          // is is enabled and allow recognizing?
          if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
              this.reset();
              this.state = STATE_FAILED;
              return;
          }

          // reset when we've reached the end
          if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
              this.state = STATE_POSSIBLE;
          }

          this.state = this.process(inputDataClone);

          // the recognizer has recognized a gesture
          // so trigger an event
          if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
              this.tryEmit(inputDataClone);
          }
      },

      /**
       * return the state of the recognizer
       * the actual recognizing happens in this method
       * @virtual
       * @param {Object} inputData
       * @returns {Const} STATE
       */
      process: function(inputData) { }, // jshint ignore:line

      /**
       * return the preferred touch-action
       * @virtual
       * @returns {Array}
       */
      getTouchAction: function() { },

      /**
       * called when the gesture isn't allowed to recognize
       * like when another is being recognized or it is disabled
       * @virtual
       */
      reset: function() { }
  };

  /**
   * get a usable string, used as event postfix
   * @param {Const} state
   * @returns {String} state
   */
  function stateStr(state) {
      if (state & STATE_CANCELLED) {
          return 'cancel';
      } else if (state & STATE_ENDED) {
          return 'end';
      } else if (state & STATE_CHANGED) {
          return 'move';
      } else if (state & STATE_BEGAN) {
          return 'start';
      }
      return '';
  }

  /**
   * direction cons to string
   * @param {Const} direction
   * @returns {String}
   */
  function directionStr(direction) {
      if (direction == DIRECTION_DOWN) {
          return 'down';
      } else if (direction == DIRECTION_UP) {
          return 'up';
      } else if (direction == DIRECTION_LEFT) {
          return 'left';
      } else if (direction == DIRECTION_RIGHT) {
          return 'right';
      }
      return '';
  }

  /**
   * get a recognizer by name if it is bound to a manager
   * @param {Recognizer|String} otherRecognizer
   * @param {Recognizer} recognizer
   * @returns {Recognizer}
   */
  function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
      var manager = recognizer.manager;
      if (manager) {
          return manager.get(otherRecognizer);
      }
      return otherRecognizer;
  }

  /**
   * This recognizer is just used as a base for the simple attribute recognizers.
   * @constructor
   * @extends Recognizer
   */
  function AttrRecognizer() {
      Recognizer.apply(this, arguments);
  }

  inherit(AttrRecognizer, Recognizer, {
      /**
       * @namespace
       * @memberof AttrRecognizer
       */
      defaults: {
          /**
           * @type {Number}
           * @default 1
           */
          pointers: 1
      },

      /**
       * Used to check if it the recognizer receives valid input, like input.distance > 10.
       * @memberof AttrRecognizer
       * @param {Object} input
       * @returns {Boolean} recognized
       */
      attrTest: function(input) {
          var optionPointers = this.options.pointers;
          return optionPointers === 0 || input.pointers.length === optionPointers;
      },

      /**
       * Process the input and return the state for the recognizer
       * @memberof AttrRecognizer
       * @param {Object} input
       * @returns {*} State
       */
      process: function(input) {
          var state = this.state;
          var eventType = input.eventType;

          var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
          var isValid = this.attrTest(input);

          // on cancel input and we've recognized before, return STATE_CANCELLED
          if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
              return state | STATE_CANCELLED;
          } else if (isRecognized || isValid) {
              if (eventType & INPUT_END) {
                  return state | STATE_ENDED;
              } else if (!(state & STATE_BEGAN)) {
                  return STATE_BEGAN;
              }
              return state | STATE_CHANGED;
          }
          return STATE_FAILED;
      }
  });

  /**
   * Pan
   * Recognized when the pointer is down and moved in the allowed direction.
   * @constructor
   * @extends AttrRecognizer
   */
  function PanRecognizer() {
      AttrRecognizer.apply(this, arguments);

      this.pX = null;
      this.pY = null;
  }

  inherit(PanRecognizer, AttrRecognizer, {
      /**
       * @namespace
       * @memberof PanRecognizer
       */
      defaults: {
          event: 'pan',
          threshold: 10,
          pointers: 1,
          direction: DIRECTION_ALL
      },

      getTouchAction: function() {
          var direction = this.options.direction;
          var actions = [];
          if (direction & DIRECTION_HORIZONTAL) {
              actions.push(TOUCH_ACTION_PAN_Y);
          }
          if (direction & DIRECTION_VERTICAL) {
              actions.push(TOUCH_ACTION_PAN_X);
          }
          return actions;
      },

      directionTest: function(input) {
          var options = this.options;
          var hasMoved = true;
          var distance = input.distance;
          var direction = input.direction;
          var x = input.deltaX;
          var y = input.deltaY;

          // lock to axis?
          if (!(direction & options.direction)) {
              if (options.direction & DIRECTION_HORIZONTAL) {
                  direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                  hasMoved = x != this.pX;
                  distance = Math.abs(input.deltaX);
              } else {
                  direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                  hasMoved = y != this.pY;
                  distance = Math.abs(input.deltaY);
              }
          }
          input.direction = direction;
          return hasMoved && distance > options.threshold && direction & options.direction;
      },

      attrTest: function(input) {
          return AttrRecognizer.prototype.attrTest.call(this, input) &&
              (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
      },

      emit: function(input) {

          this.pX = input.deltaX;
          this.pY = input.deltaY;

          var direction = directionStr(input.direction);

          if (direction) {
              input.additionalEvent = this.options.event + direction;
          }
          this._super.emit.call(this, input);
      }
  });

  /**
   * Pinch
   * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
   * @constructor
   * @extends AttrRecognizer
   */
  function PinchRecognizer() {
      AttrRecognizer.apply(this, arguments);
  }

  inherit(PinchRecognizer, AttrRecognizer, {
      /**
       * @namespace
       * @memberof PinchRecognizer
       */
      defaults: {
          event: 'pinch',
          threshold: 0,
          pointers: 2
      },

      getTouchAction: function() {
          return [TOUCH_ACTION_NONE];
      },

      attrTest: function(input) {
          return this._super.attrTest.call(this, input) &&
              (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
      },

      emit: function(input) {
          if (input.scale !== 1) {
              var inOut = input.scale < 1 ? 'in' : 'out';
              input.additionalEvent = this.options.event + inOut;
          }
          this._super.emit.call(this, input);
      }
  });

  /**
   * Press
   * Recognized when the pointer is down for x ms without any movement.
   * @constructor
   * @extends Recognizer
   */
  function PressRecognizer() {
      Recognizer.apply(this, arguments);

      this._timer = null;
      this._input = null;
  }

  inherit(PressRecognizer, Recognizer, {
      /**
       * @namespace
       * @memberof PressRecognizer
       */
      defaults: {
          event: 'press',
          pointers: 1,
          time: 251, // minimal time of the pointer to be pressed
          threshold: 9 // a minimal movement is ok, but keep it low
      },

      getTouchAction: function() {
          return [TOUCH_ACTION_AUTO];
      },

      process: function(input) {
          var options = this.options;
          var validPointers = input.pointers.length === options.pointers;
          var validMovement = input.distance < options.threshold;
          var validTime = input.deltaTime > options.time;

          this._input = input;

          // we only allow little movement
          // and we've reached an end event, so a tap is possible
          if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
              this.reset();
          } else if (input.eventType & INPUT_START) {
              this.reset();
              this._timer = setTimeoutContext(function() {
                  this.state = STATE_RECOGNIZED;
                  this.tryEmit();
              }, options.time, this);
          } else if (input.eventType & INPUT_END) {
              return STATE_RECOGNIZED;
          }
          return STATE_FAILED;
      },

      reset: function() {
          clearTimeout(this._timer);
      },

      emit: function(input) {
          if (this.state !== STATE_RECOGNIZED) {
              return;
          }

          if (input && (input.eventType & INPUT_END)) {
              this.manager.emit(this.options.event + 'up', input);
          } else {
              this._input.timeStamp = now();
              this.manager.emit(this.options.event, this._input);
          }
      }
  });

  /**
   * Rotate
   * Recognized when two or more pointer are moving in a circular motion.
   * @constructor
   * @extends AttrRecognizer
   */
  function RotateRecognizer() {
      AttrRecognizer.apply(this, arguments);
  }

  inherit(RotateRecognizer, AttrRecognizer, {
      /**
       * @namespace
       * @memberof RotateRecognizer
       */
      defaults: {
          event: 'rotate',
          threshold: 0,
          pointers: 2
      },

      getTouchAction: function() {
          return [TOUCH_ACTION_NONE];
      },

      attrTest: function(input) {
          return this._super.attrTest.call(this, input) &&
              (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
      }
  });

  /**
   * Swipe
   * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
   * @constructor
   * @extends AttrRecognizer
   */
  function SwipeRecognizer() {
      AttrRecognizer.apply(this, arguments);
  }

  inherit(SwipeRecognizer, AttrRecognizer, {
      /**
       * @namespace
       * @memberof SwipeRecognizer
       */
      defaults: {
          event: 'swipe',
          threshold: 10,
          velocity: 0.3,
          direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
          pointers: 1
      },

      getTouchAction: function() {
          return PanRecognizer.prototype.getTouchAction.call(this);
      },

      attrTest: function(input) {
          var direction = this.options.direction;
          var velocity;

          if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
              velocity = input.overallVelocity;
          } else if (direction & DIRECTION_HORIZONTAL) {
              velocity = input.overallVelocityX;
          } else if (direction & DIRECTION_VERTICAL) {
              velocity = input.overallVelocityY;
          }

          return this._super.attrTest.call(this, input) &&
              direction & input.offsetDirection &&
              input.distance > this.options.threshold &&
              input.maxPointers == this.options.pointers &&
              abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
      },

      emit: function(input) {
          var direction = directionStr(input.offsetDirection);
          if (direction) {
              this.manager.emit(this.options.event + direction, input);
          }

          this.manager.emit(this.options.event, input);
      }
  });

  /**
   * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
   * between the given interval and position. The delay option can be used to recognize multi-taps without firing
   * a single tap.
   *
   * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
   * multi-taps being recognized.
   * @constructor
   * @extends Recognizer
   */
  function TapRecognizer() {
      Recognizer.apply(this, arguments);

      // previous time and center,
      // used for tap counting
      this.pTime = false;
      this.pCenter = false;

      this._timer = null;
      this._input = null;
      this.count = 0;
  }

  inherit(TapRecognizer, Recognizer, {
      /**
       * @namespace
       * @memberof PinchRecognizer
       */
      defaults: {
          event: 'tap',
          pointers: 1,
          taps: 1,
          interval: 300, // max time between the multi-tap taps
          time: 250, // max time of the pointer to be down (like finger on the screen)
          threshold: 9, // a minimal movement is ok, but keep it low
          posThreshold: 10 // a multi-tap can be a bit off the initial position
      },

      getTouchAction: function() {
          return [TOUCH_ACTION_MANIPULATION];
      },

      process: function(input) {
          var options = this.options;

          var validPointers = input.pointers.length === options.pointers;
          var validMovement = input.distance < options.threshold;
          var validTouchTime = input.deltaTime < options.time;

          this.reset();

          if ((input.eventType & INPUT_START) && (this.count === 0)) {
              return this.failTimeout();
          }

          // we only allow little movement
          // and we've reached an end event, so a tap is possible
          if (validMovement && validTouchTime && validPointers) {
              if (input.eventType != INPUT_END) {
                  return this.failTimeout();
              }

              var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
              var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

              this.pTime = input.timeStamp;
              this.pCenter = input.center;

              if (!validMultiTap || !validInterval) {
                  this.count = 1;
              } else {
                  this.count += 1;
              }

              this._input = input;

              // if tap count matches we have recognized it,
              // else it has began recognizing...
              var tapCount = this.count % options.taps;
              if (tapCount === 0) {
                  // no failing requirements, immediately trigger the tap event
                  // or wait as long as the multitap interval to trigger
                  if (!this.hasRequireFailures()) {
                      return STATE_RECOGNIZED;
                  } else {
                      this._timer = setTimeoutContext(function() {
                          this.state = STATE_RECOGNIZED;
                          this.tryEmit();
                      }, options.interval, this);
                      return STATE_BEGAN;
                  }
              }
          }
          return STATE_FAILED;
      },

      failTimeout: function() {
          this._timer = setTimeoutContext(function() {
              this.state = STATE_FAILED;
          }, this.options.interval, this);
          return STATE_FAILED;
      },

      reset: function() {
          clearTimeout(this._timer);
      },

      emit: function() {
          if (this.state == STATE_RECOGNIZED) {
              this._input.tapCount = this.count;
              this.manager.emit(this.options.event, this._input);
          }
      }
  });

  /**
   * Simple way to create a manager with a default set of recognizers.
   * @param {HTMLElement} element
   * @param {Object} [options]
   * @constructor
   */
  function Hammer(element, options) {
      options = options || {};
      options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
      return new Manager(element, options);
  }

  /**
   * @const {string}
   */
  Hammer.VERSION = '2.0.7';

  /**
   * default settings
   * @namespace
   */
  Hammer.defaults = {
      /**
       * set if DOM events are being triggered.
       * But this is slower and unused by simple implementations, so disabled by default.
       * @type {Boolean}
       * @default false
       */
      domEvents: false,

      /**
       * The value for the touchAction property/fallback.
       * When set to `compute` it will magically set the correct value based on the added recognizers.
       * @type {String}
       * @default compute
       */
      touchAction: TOUCH_ACTION_COMPUTE,

      /**
       * @type {Boolean}
       * @default true
       */
      enable: true,

      /**
       * EXPERIMENTAL FEATURE -- can be removed/changed
       * Change the parent input target element.
       * If Null, then it is being set the to main element.
       * @type {Null|EventTarget}
       * @default null
       */
      inputTarget: null,

      /**
       * force an input class
       * @type {Null|Function}
       * @default null
       */
      inputClass: null,

      /**
       * Default recognizer setup when calling `Hammer()`
       * When creating a new Manager these will be skipped.
       * @type {Array}
       */
      preset: [
          // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
          [RotateRecognizer, {enable: false}],
          [PinchRecognizer, {enable: false}, ['rotate']],
          [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
          [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
          [TapRecognizer],
          [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
          [PressRecognizer]
      ],

      /**
       * Some CSS properties can be used to improve the working of Hammer.
       * Add them to this method and they will be set when creating a new Manager.
       * @namespace
       */
      cssProps: {
          /**
           * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userSelect: 'none',

          /**
           * Disable the Windows Phone grippers when pressing an element.
           * @type {String}
           * @default 'none'
           */
          touchSelect: 'none',

          /**
           * Disables the default callout shown when you touch and hold a touch target.
           * On iOS, when you touch and hold a touch target such as a link, Safari displays
           * a callout containing information about the link. This property allows you to disable that callout.
           * @type {String}
           * @default 'none'
           */
          touchCallout: 'none',

          /**
           * Specifies whether zooming is enabled. Used by IE10>
           * @type {String}
           * @default 'none'
           */
          contentZooming: 'none',

          /**
           * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userDrag: 'none',

          /**
           * Overrides the highlight color shown when the user taps a link or a JavaScript
           * clickable element in iOS. This property obeys the alpha value, if specified.
           * @type {String}
           * @default 'rgba(0,0,0,0)'
           */
          tapHighlightColor: 'rgba(0,0,0,0)'
      }
  };

  var STOP = 1;
  var FORCED_STOP = 2;

  /**
   * Manager
   * @param {HTMLElement} element
   * @param {Object} [options]
   * @constructor
   */
  function Manager(element, options) {
      this.options = assign({}, Hammer.defaults, options || {});

      this.options.inputTarget = this.options.inputTarget || element;

      this.handlers = {};
      this.session = {};
      this.recognizers = [];
      this.oldCssProps = {};

      this.element = element;
      this.input = createInputInstance(this);
      this.touchAction = new TouchAction(this, this.options.touchAction);

      toggleCssProps(this, true);

      each(this.options.recognizers, function(item) {
          var recognizer = this.add(new (item[0])(item[1]));
          item[2] && recognizer.recognizeWith(item[2]);
          item[3] && recognizer.requireFailure(item[3]);
      }, this);
  }

  Manager.prototype = {
      /**
       * set options
       * @param {Object} options
       * @returns {Manager}
       */
      set: function(options) {
          assign(this.options, options);

          // Options that need a little more setup
          if (options.touchAction) {
              this.touchAction.update();
          }
          if (options.inputTarget) {
              // Clean up existing event listeners and reinitialize
              this.input.destroy();
              this.input.target = options.inputTarget;
              this.input.init();
          }
          return this;
      },

      /**
       * stop recognizing for this session.
       * This session will be discarded, when a new [input]start event is fired.
       * When forced, the recognizer cycle is stopped immediately.
       * @param {Boolean} [force]
       */
      stop: function(force) {
          this.session.stopped = force ? FORCED_STOP : STOP;
      },

      /**
       * run the recognizers!
       * called by the inputHandler function on every movement of the pointers (touches)
       * it walks through all the recognizers and tries to detect the gesture that is being made
       * @param {Object} inputData
       */
      recognize: function(inputData) {
          var session = this.session;
          if (session.stopped) {
              return;
          }

          // run the touch-action polyfill
          this.touchAction.preventDefaults(inputData);

          var recognizer;
          var recognizers = this.recognizers;

          // this holds the recognizer that is being recognized.
          // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
          // if no recognizer is detecting a thing, it is set to `null`
          var curRecognizer = session.curRecognizer;

          // reset when the last recognizer is recognized
          // or when we're in a new session
          if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
              curRecognizer = session.curRecognizer = null;
          }

          var i = 0;
          while (i < recognizers.length) {
              recognizer = recognizers[i];

              // find out if we are allowed try to recognize the input for this one.
              // 1.   allow if the session is NOT forced stopped (see the .stop() method)
              // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
              //      that is being recognized.
              // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
              //      this can be setup with the `recognizeWith()` method on the recognizer.
              if (session.stopped !== FORCED_STOP && ( // 1
                      !curRecognizer || recognizer == curRecognizer || // 2
                      recognizer.canRecognizeWith(curRecognizer))) { // 3
                  recognizer.recognize(inputData);
              } else {
                  recognizer.reset();
              }

              // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
              // current active recognizer. but only if we don't already have an active recognizer
              if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                  curRecognizer = session.curRecognizer = recognizer;
              }
              i++;
          }
      },

      /**
       * get a recognizer by its event name.
       * @param {Recognizer|String} recognizer
       * @returns {Recognizer|Null}
       */
      get: function(recognizer) {
          if (recognizer instanceof Recognizer) {
              return recognizer;
          }

          var recognizers = this.recognizers;
          for (var i = 0; i < recognizers.length; i++) {
              if (recognizers[i].options.event == recognizer) {
                  return recognizers[i];
              }
          }
          return null;
      },

      /**
       * add a recognizer to the manager
       * existing recognizers with the same event name will be removed
       * @param {Recognizer} recognizer
       * @returns {Recognizer|Manager}
       */
      add: function(recognizer) {
          if (invokeArrayArg(recognizer, 'add', this)) {
              return this;
          }

          // remove existing
          var existing = this.get(recognizer.options.event);
          if (existing) {
              this.remove(existing);
          }

          this.recognizers.push(recognizer);
          recognizer.manager = this;

          this.touchAction.update();
          return recognizer;
      },

      /**
       * remove a recognizer by name or instance
       * @param {Recognizer|String} recognizer
       * @returns {Manager}
       */
      remove: function(recognizer) {
          if (invokeArrayArg(recognizer, 'remove', this)) {
              return this;
          }

          recognizer = this.get(recognizer);

          // let's make sure this recognizer exists
          if (recognizer) {
              var recognizers = this.recognizers;
              var index = inArray(recognizers, recognizer);

              if (index !== -1) {
                  recognizers.splice(index, 1);
                  this.touchAction.update();
              }
          }

          return this;
      },

      /**
       * bind event
       * @param {String} events
       * @param {Function} handler
       * @returns {EventEmitter} this
       */
      on: function(events, handler) {
          if (events === undefined) {
              return;
          }
          if (handler === undefined) {
              return;
          }

          var handlers = this.handlers;
          each(splitStr(events), function(event) {
              handlers[event] = handlers[event] || [];
              handlers[event].push(handler);
          });
          return this;
      },

      /**
       * unbind event, leave emit blank to remove all handlers
       * @param {String} events
       * @param {Function} [handler]
       * @returns {EventEmitter} this
       */
      off: function(events, handler) {
          if (events === undefined) {
              return;
          }

          var handlers = this.handlers;
          each(splitStr(events), function(event) {
              if (!handler) {
                  delete handlers[event];
              } else {
                  handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
              }
          });
          return this;
      },

      /**
       * emit event to the listeners
       * @param {String} event
       * @param {Object} data
       */
      emit: function(event, data) {
          // we also want to trigger dom events
          if (this.options.domEvents) {
              triggerDomEvent(event, data);
          }

          // no handlers, so skip it all
          var handlers = this.handlers[event] && this.handlers[event].slice();
          if (!handlers || !handlers.length) {
              return;
          }

          data.type = event;
          data.preventDefault = function() {
              data.srcEvent.preventDefault();
          };

          var i = 0;
          while (i < handlers.length) {
              handlers[i](data);
              i++;
          }
      },

      /**
       * destroy the manager and unbinds all events
       * it doesn't unbind dom events, that is the user own responsibility
       */
      destroy: function() {
          this.element && toggleCssProps(this, false);

          this.handlers = {};
          this.session = {};
          this.input.destroy();
          this.element = null;
      }
  };

  /**
   * add/remove the css properties as defined in manager.options.cssProps
   * @param {Manager} manager
   * @param {Boolean} add
   */
  function toggleCssProps(manager, add) {
      var element = manager.element;
      if (!element.style) {
          return;
      }
      var prop;
      each(manager.options.cssProps, function(value, name) {
          prop = prefixed(element.style, name);
          if (add) {
              manager.oldCssProps[prop] = element.style[prop];
              element.style[prop] = value;
          } else {
              element.style[prop] = manager.oldCssProps[prop] || '';
          }
      });
      if (!add) {
          manager.oldCssProps = {};
      }
  }

  /**
   * trigger dom event
   * @param {String} event
   * @param {Object} data
   */
  function triggerDomEvent(event, data) {
      var gestureEvent = document.createEvent('Event');
      gestureEvent.initEvent(event, true, true);
      gestureEvent.gesture = data;
      data.target.dispatchEvent(gestureEvent);
  }

  assign(Hammer, {
      INPUT_START: INPUT_START,
      INPUT_MOVE: INPUT_MOVE,
      INPUT_END: INPUT_END,
      INPUT_CANCEL: INPUT_CANCEL,

      STATE_POSSIBLE: STATE_POSSIBLE,
      STATE_BEGAN: STATE_BEGAN,
      STATE_CHANGED: STATE_CHANGED,
      STATE_ENDED: STATE_ENDED,
      STATE_RECOGNIZED: STATE_RECOGNIZED,
      STATE_CANCELLED: STATE_CANCELLED,
      STATE_FAILED: STATE_FAILED,

      DIRECTION_NONE: DIRECTION_NONE,
      DIRECTION_LEFT: DIRECTION_LEFT,
      DIRECTION_RIGHT: DIRECTION_RIGHT,
      DIRECTION_UP: DIRECTION_UP,
      DIRECTION_DOWN: DIRECTION_DOWN,
      DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
      DIRECTION_VERTICAL: DIRECTION_VERTICAL,
      DIRECTION_ALL: DIRECTION_ALL,

      Manager: Manager,
      Input: Input,
      TouchAction: TouchAction,

      TouchInput: TouchInput,
      MouseInput: MouseInput,
      PointerEventInput: PointerEventInput,
      TouchMouseInput: TouchMouseInput,
      SingleTouchInput: SingleTouchInput,

      Recognizer: Recognizer,
      AttrRecognizer: AttrRecognizer,
      Tap: TapRecognizer,
      Pan: PanRecognizer,
      Swipe: SwipeRecognizer,
      Pinch: PinchRecognizer,
      Rotate: RotateRecognizer,
      Press: PressRecognizer,

      on: addEventListeners,
      off: removeEventListeners,
      each: each,
      merge: merge,
      extend: extend,
      assign: assign,
      inherit: inherit,
      bindFn: bindFn,
      prefixed: prefixed
  });

  // this prevents errors when Hammer is loaded in the presence of an AMD
  //  style loader but by script tag, not by the loader.
  var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
  freeGlobal.Hammer = Hammer;

  if (typeof undefined === 'function' && undefined.amd) {
      undefined(function() {
          return Hammer;
      });
  } else if ('object' != 'undefined' && module.exports) {
      module.exports = Hammer;
  } else {
      window[exportName] = Hammer;
  }

  })(window, document, 'Hammer');
  });

  var Responsive = function () {
    function Responsive(instance) {
      classCallCheck(this, Responsive);

      this.instance = instance;
      this.initialize();
    }

    createClass(Responsive, [{
      key: 'initialize',
      value: function initialize() {
        this.index = is.number(this.instance.current[0]) ? this.instance.current[0] : 0;
        this.duration = parseInt(this.instance.options.responsiveDuration, 10);

        var options = this.instance.options;

        if (options.breakWidth === false || options.breakWidth === null) {
          return;
        }

        // init status
        this.$rely = window;
        if (options.resizeReference === 'self') {
          this.$rely = this.instance.element;
        } else if (options.resizeReference !== 'window' &&
        /* eslint no-magic-numbers: ["error", { "ignore": [0] }]*/
        query(options.resizeReference).length > 0) {
          this.$rely = query(options.resizeReference);
        }

        this.effects = {
          in: options.responsiveEffect,
          out: this.revertClass(options.responsiveEffect)
        };

        if (!(this.$rely.clientWidth > options.breakWidth)) {
          this.toggle(true);
        }
      }
    }, {
      key: 'revertClass',
      value: function revertClass(str) {
        var classes = str.split(' ');
        var inre = ['Up', 'Down', 'In', 'Out', 'Left', 'Right', 'Top', 'Bottom'];
        var len = classes.length;
        var outre = ['Down', 'Up', 'Out', 'In', 'Right', 'Left', 'Bottom', 'Top'];
        var output = '',
            re = '',
            reNum = '';

        var reArray = [];

        for (var n = 0; n < len; n++) {
          for (var m = 0; m < inre.length; m++) {
            re = new RegExp(inre[m]);
            if (re.test(classes[n])) {
              reArray.push(m);
            }
          }
          for (var l = 0; l < reArray.length; l++) {
            reNum = reArray[l];
            classes[n] = classes[n].replace(inre[reNum], reNum);
          }
          for (var k = 0; k < reArray.length; k++) {
            reNum = reArray[k];
            classes[n] = classes[n].replace(reNum, outre[reNum]);
          }
          output += ' ' + classes[n];
        }
        return output.trim();
      }
    }, {
      key: 'initDistance',
      value: function initDistance() {
        var direction = this.instance.options.horizontal ? 'width' : 'height';
        this.instance.$panes.map(setStyle(defineProperty({
          transform: 'translateY(-50%)',
          opacity: '0'
        }, direction, 'auto')));
        // console.log(this.instance.$panes)
        // console.log(this.instance.$contentInners)
        this.instance.$contentInners.map(setStyle(defineProperty({}, direction, 'auto')));

        setStyle({ height: outerHeight(this.instance.$contentInners[this.index]) + 'px' }, this.instance.element);
      }
    }, {
      key: 'toggle',
      value: function toggle(toBuild) {
        if (toBuild) {
          this.build();
        } else {
          this.destroy();
        }
      }
    }, {
      key: 'build',
      value: function build() {
        var _this = this,
            _$dropdownList;

        if (this.instance.is('built')) {
          return;
        }

        this.initDistance();

        var classes = this.instance.classes;
        var options = this.instance.options;

        this.$dropdown = parseHTML('<div class="' + classes.DROPDOWN + '"></div>');
        this.$dropdownlabel = compose(append(this.instance.$headers[this.instance.current[0]].innerHTML), empty, addClass(classes.DROPDOWNLABEL), parseHTML)(options.dropdownLabelTpl);
        this.$dropdownList = parseHTML('<ul class="' + classes.DROPDOWNLIST + '"></ul>');
        this.$dropdownItems = Array.from(Array(this.instance.size), function (_, index) {
          var $li = parseHTML('<li>' + _this.instance.$headers[index].innerHTML + '</li>');
          if (index === _this.instance.current[0]) {
            addClass(classes.ACTIVE, $li);
          }
          return $li;
        });
        (_$dropdownList = this.$dropdownList).append.apply(_$dropdownList, toConsumableArray(this.$dropdownItems));
        if (this.instance.options.theme) {
          addClass(this.instance.getThemeClass(), this.$dropdown);
        }
        var insertBeforeInstanceElement = function insertBeforeInstanceElement(dropdown) {
          return compose(insertBefore(dropdown), addClass(classes.RESPONSIVE))(_this.instance.element);
        };
        compose(insertBeforeInstanceElement, append(this.$dropdownList), append(this.$dropdownlabel))(this.$dropdown);

        this.bind();

        this.instance.enter('built');

        if (this.instance.is('initialized')) {
          this.instance.open(this.instance.current[0], false);
        }
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        if (!this.instance.is('built')) {
          return;
        }

        this.$dropdown.map(remove);
        this.instance.$panes.map(removeAttribute('style'));
        compose(removeClass(this.instance.classes.RESPONSIVE), removeAttribute('style'))(this.instance.element);

        this.unbind();

        this.instance.leave('built');
        for (var i = 0; i < this.instance.$panes.length; i++) {
          this.instance.close(i, false);
        }

        this.instance.open(this.index, false);
      }
    }, {
      key: 'bind',
      value: function bind() {
        var _this2 = this;

        this.dropdown = new hammer(this.$dropdown);
        this.dropdown.on('tap', function (e) {
          if (_this2.instance.is('disabled')) {
            return;
          }
          var target = e.target;

          var matchTagName = function matchTagName(tagName) {
            return function (el) {
              return el.tagName === tagName;
            };
          };
          var aTag = target.tagName === 'A' ? target : parentWith(matchTagName('A'), target);
          var liTag = target.tagName === 'LI' ? target : parentWith(matchTagName('LI'), target);
          if (aTag) {
            _this2.switch();
          } else if (liTag) {
            _this2.labelActive(children(parent(liTag)).indexOf(liTag));
          }
        });
      }
    }, {
      key: 'unbind',
      value: function unbind() {
        this.dropdown.destroy();
      }
    }, {
      key: 'switch',
      value: function _switch() {
        toggleClass(this.instance.classes.DROPDOWNOPEN, this.$dropdown);
      }
    }, {
      key: 'labelActive',
      value: function labelActive(index) {
        this.index = index;
        if (this.instance.current.indexOf(index) !== -1) {
          removeClass(this.instance.classes.DROPDOWNOPEN, this.$dropdown);
          return;
        }

        this.instance.toggle(index);

        removeClass(this.instance.classes.ACTIVE, this.$dropdownItems[this.instance.prev[0]]);
        addClass(this.instance.classes.ACTIVE, this.$dropdownItems[index]);
        html(this.$dropdownItems[index].innerHTML, this.$dropdownlabel);
        removeClass(this.instance.classes.DROPDOWNOPEN, this.$dropdown);
      }
    }, {
      key: 'open',
      value: function open(index, trigger) {
        var _this3 = this;

        this.index = index;

        var $pane = this.instance.$panes[index];

        anime_min({
          targets: $pane,
          translateY: 0,
          opacity: 1,
          duration: trigger ? this.duration : 1,
          easing: this.effects.in,
          begin: function begin() {
            addClass(_this3.instance.classes.ACTIVE, $pane);
          }
        });

        this.resetHeight(!trigger);
      }
    }, {
      key: 'close',
      value: function close(index, trigger) {
        var _this4 = this;

        var pane = this.instance.$panes[this.instance.prev[0]];
        // console.log(this.instance.prev)
        anime_min({
          targets: pane,
          translateY: '50%',
          opacity: 0,
          duration: trigger ? this.duration : 1,
          easing: this.effects.out,
          complete: function complete() {
            return compose(setStyle({ transform: 'translateY(-50%)' }), removeClass(_this4.instance.classes.ACTIVE))(pane);
          }
        });
      }
    }, {
      key: 'resetHeight',
      value: function resetHeight() {
        var immediately = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

        if (!this.instance.is('built')) {
          return;
        }

        var innerHeight = outerHeight(this.instance.$contentInners[this.index]);
        if (immediately) {
          setStyle({ height: innerHeight + 'px' }, this.instance.element);
        } else {
          anime_min({
            targets: this.instance.element,
            height: innerHeight,
            duration: this.duration,
            easing: 'linear'
          });
        }
      }
    }, {
      key: 'resize',
      value: function resize() {
        var breakWidth = this.instance.options.breakWidth;

        if (breakWidth === false || breakWidth === null) {
          return;
        }

        if (this.$rely.width() > breakWidth) {
          this.toggle(false);
        } else {
          this.resetHeight(true);
          this.toggle(true);
        }
      }
    }]);
    return Responsive;
  }();

  var _dec, _dec2, _dec3, _dec4, _dec5, _class;

  var Accordion = (_dec = themeable(), _dec2 = styleable(classes), _dec3 = eventable(events), _dec4 = stateable(), _dec5 = register(namespace, {
    defaults: defaults$1,
    methods: methods,
    dependencies: dependencies
  }, info), _dec(_class = _dec2(_class = _dec3(_class = _dec4(_class = _dec5(_class = function (_Component) {
    inherits(Accordion, _Component);

    function Accordion(element) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      classCallCheck(this, Accordion);

      var _this = possibleConstructorReturn(this, (Accordion.__proto__ || Object.getPrototypeOf(Accordion)).call(this, namespace, element));

      _this.options = deepMerge(defaults$1, options, _this.getDataOptions());

      _this.initClasses(classes);
      _this.initStates();
      _this.initialize();
      return _this;
    }

    createClass(Accordion, [{
      key: 'initialize',
      value: function initialize() {
        this.initPointer();
        this.processHtml();

        this.ANIMATE = new Animate(this);
        this.RESPONSIVE = new Responsive(this);

        this.bind();
        this.open(this.current, false);

        this.enter('initialized');
        this.trigger(events.READY);
      }
    }, {
      key: 'initPointer',
      value: function initPointer() {
        this.$panes = children(this.element);
        this.$headers = this.$panes.map(find('.' + this.classes.PANEHEADER));
        this.$contents = this.$panes.map(find('.' + this.classes.PANECONTENT));
        this.$contentInners = this.$contents.map(find('.' + this.classes.PANECONTENTINNER));

        this.size = this.$panes.length;
        this.isResponsive = this.options.breakWidth === null ? false : Pj.windowWidth <= this.options.breakWidth;

        this.resetData();
      }
    }, {
      key: 'resetData',
      value: function resetData() {
        var $activeItem = this.$panes.map(find('.' + this.classes.ACTIVE)).filter(Boolean);
        if ($activeItem.length > 0) {
          this.current = $activeItem.map(function (_, index) {
            return index;
          });
        } else if (this.options.initialIndex) {
          this.current = this.parseIndex(this.options.initialIndex);
        } else {
          this.current = [0];
        }

        this.prev = this.current;
      }
    }, {
      key: 'processHtml',
      value: function processHtml() {
        addClass(this.classes.NAMESPACE, this.element);

        if (this.options.horizontal) {
          addClass(this.classes.HORIZONTAL, this.element);
        }

        if (this.options.theme) {
          addClass(this.getThemeClass(), this.element);
        }
        this.$panes.map(addClass(this.classes.PANE));
        this.$headers.map(addClass(this.classes.PANEHEADER));
        this.$contents.map(addClass(this.classes.PANECONTENT));
        this.$contentInners.map(addClass(this.classes.PANECONTENTINNER));
      }
    }, {
      key: 'parseIndex',
      value: function parseIndex(index) {
        var arr = [];

        switch (typeof index === 'undefined' ? 'undefined' : _typeof(index)) {
          case 'string':
            if (index === 'all') {
              for (var i = 0; i < this.size; i++) {
                arr.push(i);
              }
            }
            break;
          case 'number':
            arr.push(index);
            break;
          case 'object':
            if (Array.isArray(index)) {
              arr = index;
            }
            break;
          case 'undefined':
            arr = [0];
            break;
          default:
            break;
        }

        if (!this.options.multiple) {
          arr = [arr[0]];
        }

        return arr;
      }
    }, {
      key: 'bind',
      value: function bind() {
        var _this2 = this;

        this.$panes.map(function (pane, index) {
          return bindEvent({
            type: _this2.eventName('click'),
            identity: '.' + _this2.classes.PANEHEADER,
            handler: function handler() {
              if (_this2.is('disabled')) {
                return false;
              }
              _this2.toggle(index);
              return false;
            }
          }, pane);
        });
      }
    }, {
      key: 'toggle',
      value: function toggle(index) {
        var pos = this.current.includes(index);
        this.prev = this.current;

        if (!this.options.multiple) {
          this.close(this.prev);
        }

        if (!pos) {
          if (!this.options.multiple || this.is('built') || this.options.horizontal) {
            this.current = [];
          }

          this.current.push(index);
          this.open(index);
        } else {
          this.current.splice(this.current.indexOf(index), 1);
          this.close(index);
        }
      }
    }, {
      key: 'open',
      value: function open(index) {
        var _this3 = this;

        var trigger$$1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        if (index === null) {
          return;
        }

        var arr = Array.isArray(index) ? index : [index];
        var target = this.is('built') ? this.RESPONSIVE : this.ANIMATE;
        arr.map(function (index) {
          if (!_this3.is('built')) {
            addClass(_this3.classes.ACTIVE, _this3.$panes[index]);
          }
          return target.open(index, trigger$$1);
        });

        if (this.is('initialized')) {
          this.trigger(events.OPEN, index);
        }
      }
    }, {
      key: 'close',
      value: function close(index) {
        var _this4 = this;

        var trigger$$1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        if (index === null) {
          return;
        }

        var arr = Array.isArray(index) ? index : [index];
        var target = this.is('built') ? this.RESPONSIVE : this.ANIMATE;
        arr.forEach(function (index) {
          target.close(index, trigger$$1);

          if (!_this4.is('built')) {
            removeClass(_this4.classes.ACTIVE, _this4.$panes[index]);
          }
        });

        if (this.is('initialized')) {
          this.trigger(events.CLOSE, index);
        }
      }
    }, {
      key: 'resize',
      value: function resize() {
        this.ANIMATE.resetWidth(true);
        this.RESPONSIVE.resize();
        this.trigger(events.RESIZE);
      }
    }]);
    return Accordion;
  }(Plugin)) || _class) || _class) || _class) || _class) || _class);

  exports.default = Accordion;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
