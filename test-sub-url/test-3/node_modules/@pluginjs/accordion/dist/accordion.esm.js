import anime from 'animejs';
import { setStyle, contentWidth, outerHeight, outerHeightWithMargin, outerWidth, outerWidthWithMargin } from '@pluginjs/styled';
import { parentWith, empty, append, parent, parseHTML, html, insertBefore, removeAttribute, remove, children, query, find } from '@pluginjs/dom';
import { hasClass, addClass, removeClass, toggleClass } from '@pluginjs/classes';
import Hammer from 'hammerjs';
import Component from '@pluginjs/component';
import { bindEvent } from '@pluginjs/events';
import Pj, { eventable, register, stateable, styleable, themeable } from '@pluginjs/pluginjs';

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};
function nub(arr) {
  return Array.from(new Set(arr));
}
function isPlainObject(data) {
  if (typeof data !== 'object') {
    return false;
  }

  if (data === null) {
    return false;
  }

  if (data instanceof Set || data instanceof Map) {
    return false;
  }

  if (Array.isArray(data)) {
    return false;
  }

  return true;
}
function deepMergeTwo(x, y) {
  if (isPlainObject(y) && isPlainObject(x) || isPlainObject(x) && Array.isArray(y)) {
    return fromPairs$1(nub(Object.keys(x).concat(Object.keys(y))).map(key => [key, deepMergeTwo(x[key], y[key])]));
  }

  if (isPlainObject(y) && typeof x === 'function') {
    return Object.assign(function (...args) {
      return x.apply(this, args);
    }, y);
  }

  if (isPlainObject(y) && Array.isArray(x)) {
    return Object.assign([], x, y);
  }

  if (isPlainObject(x) && typeof y === 'function') {
    return Object.assign(function (...args) {
      return y.apply(this, args);
    }, x);
  }

  if (Array.isArray(y) && Array.isArray(x)) {
    // return x.concat(y)
    return nub(Object.keys(y).concat(Object.keys(x))).map(index => deepMergeTwo(x[index], y[index]));
  }

  if (typeof y === 'undefined') {
    return x;
  }
  return y;
}
function isObject(obj) {
  return Object(obj) === obj;
}
function deepMerge(...args) {
  return args.filter(isObject).reduce(deepMergeTwo);
}

const compose = (...fn) => {
  const callback = (...args) => fn.reduceRight((r, i, index) => {
    if (Array.isArray(r) && index === fn.length - 1) {
      return i(...r);
    }
    return i(r);
  }, args);
  callback.currylen = fn[fn.curylen || fn.length - 1].length;
  return callback;
};

function fromPairs$1(arr) {
  return arr.reduce((r, [k, v]) => _extends({}, r, {
    [k]: v
  }), {});
}

const namespace = 'accordion';

const events = {
  READY: 'ready',
  OPEN: 'open',
  CLOSE: 'close',
  RESIZE: 'resize'
};

const classes = {
  NAMESPACE: `pj-${namespace}`,
  THEME: '{namespace}--{theme}',
  ACTIVE: '{namespace}-active',
  DISABLED: '{namespace}-disabled',

  RESPONSIVE: '{namespace}-responsive',
  HORIZONTAL: '{namespace}-horizontal',

  DROPDOWN: '{namespace}-dropdown',
  DROPDOWNLABEL: '{namespace}-dropdown-label',
  DROPDOWNLIST: '{namespace}-dropdown-list',
  DROPDOWNOPEN: '{namespace}-open',

  // components
  PANE: '{namespace}-pane',
  PANEHEADER: '{namespace}-pane-header',
  PANECONTENT: '{namespace}-pane-content',
  PANECONTENTINNER: '{namespace}-pane-content-inner'
};

const methods = ['open', 'close'];

const defaults = {
  theme: null,
  panelSelector: null,
  initialIndex: 0,
  duration: 300,
  horizontal: false,
  multiple: false,
  ajax: false,

  // Responsive
  breakWidth: null,
  resizeReference: 'window',
  responsiveEffect: 'easeInQuad',
  dropdownLabelTpl: '<a href="javascript:void(0)"></a>',
  responsiveDuration: 300,

  // callback
  onReady: null
};

const dependencies = ['Hammer', 'anime'];

const info = { version: '0.2.1' };

let Animate = class Animate {
  constructor(instance) {
    this.instance = instance;
    this.initialize();
  }

  initialize() {
    this.horizontal = this.instance.options.horizontal;
    this.property = this.horizontal ? 'width' : 'height';
    this.initDistance();
    this.instance.$panes.map(setStyle({ [this.property]: `${this.headerDistance}px` }));
    if (this.horizontal) {
      this.instance.$contentInners.map(setStyle({ width: `${this.contentDistance[0]}px` }));
      this.instance.$contentInners.map((item, index) => setStyle({ width: `${this.contentDistance[index]}px` }, item));
    }
  }

  initDistance() {
    if (this.horizontal) {
      this.getPaneSpace();
    }

    this.getHeaderDistance();
    this.getContentDistance();
  }

  getPaneSpace() {
    this.paneSpace = outerWidthWithMargin(this.instance.$panes[1]) - outerWidth(this.instance.$panes[1]);
    return this.paneSpace;
  }

  getHeaderDistance() {
    this.headerDistance = outerHeightWithMargin(this.instance.$headers[0]) + 2;
  }

  getContentDistance() {
    const innerWidth = contentWidth(this.instance.element);
    const size = this.instance.size;
    this.contentDistance = this.instance.$contentInners.map(element => {
      if (this.horizontal) {
        return innerWidth - size * this.headerDistance - (size - 1) * this.paneSpace;
      }
      return compose(outerHeight, compose(parentWith, hasClass)(this.instance.classes.PANECONTENT))(element);
    });
    return this.contentDistance;
  }

  resetWidth(immediately = false) {
    if (this.instance.is('built')) {
      return;
    }

    const current = this.instance.current;

    this.getContentDistance();

    if (this.horizontal) {
      this.instance.$contentInners.map(setStyle({ width: `${this.contentDistance[0]}px` }));
    }

    for (let i = 0; i < current.length; i++) {
      const index = current[i];
      const pane = this.instance.$panes[index];
      const opts = {
        targets: pane,
        duration: immediately ? 1 : 200,
        easing: 'linear'
      };

      opts[this.property] = this.headerDistance + this.contentDistance[index];

      anime(opts);
    }
  }

  open(index, trigger) {
    const pane = this.instance.$panes[index];
    const opts = {
      targets: pane,
      duration: trigger ? 200 : 1,
      easing: 'linear'
    };

    opts[this.property] = this.headerDistance + this.contentDistance[index];

    anime(opts);
  }

  close(index, trigger) {
    const pane = this.instance.$panes[index];
    const opts = {
      targets: pane,
      duration: trigger ? 200 : 1,
      easing: 'linear'
    };

    opts[this.property] = this.headerDistance;

    anime(opts);
  }
};

/*eslint-disable */
/* Credit to http://is.js.org MIT */
const toString = Object.prototype.toString;
const is = {
  // Type checks
  /* -------------------------------------------------------------------------- */
  // is a given value Arguments?
  arguments: function (value) {
    // fallback check is for IE
    return toString.call(value) === '[object Arguments]' || value != null && typeof value === 'object' && 'callee' in value;
  },

  // is a given value Array?
  array: function (val) {
    if (Array.isArray) {
      return Array.isArray(val);
    }
    return toString.call(val) === '[object Array]';
  },

  // is a given value Boolean?
  boolean: function (val) {
    return val === true || val === false || toString.call(val) === '[object Boolean]';
  },

  // is a given value Char?
  char: function (val) {
    return this.string(val) && val.length === 1;
  },

  // is a given value Date Object?
  date: function (value) {
    return toString.call(value) === '[object Date]';
  },

  // is a given object a DOM node?
  domNode: function (object) {
    return this.object(object) && object.nodeType > 0;
  },

  // is a given value Error object?
  error: function (val) {
    return toString.call(val) === '[object Error]';
  },

  // is a given value function?
  function: function (val) {
    // fallback check is for IE
    return toString.call(val) === '[object Function]' || typeof val === 'function';
  },

  // is given value a pure JSON object?
  json: function (value) {
    return toString.call(value) === '[object Object]';
  },

  // is a given value NaN?
  nan: function (val) {
    // NaN is number :) Also it is the only value which does not equal itself
    return val !== val;
  },

  // is a given value null?
  null: function (val) {
    return val === null;
  },

  // is a given value number?
  number: function (val) {
    return !this.nan(val) && toString.call(val) === '[object Number]';
  },

  // is a given value object?
  object: function (val) {
    return Object(val) === val;
  },

  // is a given value empty object?
  emptyObject: function (val) {
    return this.object(val) && Object.getOwnPropertyNames(val).length == 0;
  },

  // is a given value RegExp?
  regexp: function (val) {
    return toString.call(val) === '[object RegExp]';
  },

  // is a given value String?
  string: function (val) {
    return typeof val === 'string' || toString.call(val) === '[object String]';
  },

  // is a given value undefined?
  undefined: function (val) {
    return val === void 0;
  },

  // Arithmetic checks
  /* -------------------------------------------------------------------------- */
  // is a given value numeric?
  numeric: function (n) {
    return (this.number(n) || this.string(n)) && !this.nan(n - parseFloat(n));
  },

  // is a given number percentage?
  percentage: function (n) {
    return typeof n === 'string' && n.indexOf('%') !== -1;
  },

  // is a given number decimal?
  decimal: function (n) {
    return this.number(n) && n % 1 !== 0;
  },

  // is a given number finite?
  finite: function (n) {
    if (isFinite) {
      return isFinite(n);
    }
    return !this.infinite(n) && !this.nan(n);
  },

  // is a given number infinite?
  infinite: function (n) {
    return n === Infinity || n === -Infinity;
  },

  integer: function (n) {
    return this.number(n) && n % 1 === 0;
  },

  // is a given number negative?
  negative: function (n) {
    return this.number(n) && n < 0;
  },

  // is a given number positive?
  positive: function (n) {
    return this.number(n) && n > 0;
  }
};

let Responsive = class Responsive {
  constructor(instance) {
    this.instance = instance;
    this.initialize();
  }

  initialize() {
    this.index = is.number(this.instance.current[0]) ? this.instance.current[0] : 0;
    this.duration = parseInt(this.instance.options.responsiveDuration, 10);

    const options = this.instance.options;

    if (options.breakWidth === false || options.breakWidth === null) {
      return;
    }

    // init status
    this.$rely = window;
    if (options.resizeReference === 'self') {
      this.$rely = this.instance.element;
    } else if (options.resizeReference !== 'window' &&
    /* eslint no-magic-numbers: ["error", { "ignore": [0] }]*/
    query(options.resizeReference).length > 0) {
      this.$rely = query(options.resizeReference);
    }

    this.effects = {
      in: options.responsiveEffect,
      out: this.revertClass(options.responsiveEffect)
    };

    if (!(this.$rely.clientWidth > options.breakWidth)) {
      this.toggle(true);
    }
  }

  revertClass(str) {
    const classes = str.split(' ');
    const inre = ['Up', 'Down', 'In', 'Out', 'Left', 'Right', 'Top', 'Bottom'];
    const len = classes.length;
    const outre = ['Down', 'Up', 'Out', 'In', 'Right', 'Left', 'Bottom', 'Top'];
    let [output, re, reNum] = ['', '', ''];
    const reArray = [];

    for (let n = 0; n < len; n++) {
      for (let m = 0; m < inre.length; m++) {
        re = new RegExp(inre[m]);
        if (re.test(classes[n])) {
          reArray.push(m);
        }
      }
      for (let l = 0; l < reArray.length; l++) {
        reNum = reArray[l];
        classes[n] = classes[n].replace(inre[reNum], reNum);
      }
      for (let k = 0; k < reArray.length; k++) {
        reNum = reArray[k];
        classes[n] = classes[n].replace(reNum, outre[reNum]);
      }
      output += ` ${classes[n]}`;
    }
    return output.trim();
  }

  initDistance() {
    const direction = this.instance.options.horizontal ? 'width' : 'height';
    this.instance.$panes.map(setStyle({
      transform: 'translateY(-50%)',
      opacity: '0',
      [direction]: 'auto'
    }));
    // console.log(this.instance.$panes)
    // console.log(this.instance.$contentInners)
    this.instance.$contentInners.map(setStyle({ [direction]: 'auto' }));

    setStyle({ height: `${outerHeight(this.instance.$contentInners[this.index])}px` }, this.instance.element);
  }

  toggle(toBuild) {
    if (toBuild) {
      this.build();
    } else {
      this.destroy();
    }
  }

  build() {
    if (this.instance.is('built')) {
      return;
    }

    this.initDistance();

    const classes = this.instance.classes;
    const options = this.instance.options;

    this.$dropdown = parseHTML(`<div class="${classes.DROPDOWN}"></div>`);
    this.$dropdownlabel = compose(append(this.instance.$headers[this.instance.current[0]].innerHTML), empty, addClass(classes.DROPDOWNLABEL), parseHTML)(options.dropdownLabelTpl);
    this.$dropdownList = parseHTML(`<ul class="${classes.DROPDOWNLIST}"></ul>`);
    this.$dropdownItems = Array.from(Array(this.instance.size), (_, index) => {
      const $li = parseHTML(`<li>${this.instance.$headers[index].innerHTML}</li>`);
      if (index === this.instance.current[0]) {
        addClass(classes.ACTIVE, $li);
      }
      return $li;
    });
    this.$dropdownList.append(...this.$dropdownItems);
    if (this.instance.options.theme) {
      addClass(this.instance.getThemeClass(), this.$dropdown);
    }
    const insertBeforeInstanceElement = dropdown => compose(insertBefore(dropdown), addClass(classes.RESPONSIVE))(this.instance.element);
    compose(insertBeforeInstanceElement, append(this.$dropdownList), append(this.$dropdownlabel))(this.$dropdown);

    this.bind();

    this.instance.enter('built');

    if (this.instance.is('initialized')) {
      this.instance.open(this.instance.current[0], false);
    }
  }

  destroy() {
    if (!this.instance.is('built')) {
      return;
    }

    this.$dropdown.map(remove);
    this.instance.$panes.map(removeAttribute('style'));
    compose(removeClass(this.instance.classes.RESPONSIVE), removeAttribute('style'))(this.instance.element);

    this.unbind();

    this.instance.leave('built');
    for (let i = 0; i < this.instance.$panes.length; i++) {
      this.instance.close(i, false);
    }

    this.instance.open(this.index, false);
  }

  bind() {
    this.dropdown = new Hammer(this.$dropdown);
    this.dropdown.on('tap', e => {
      if (this.instance.is('disabled')) {
        return;
      }
      const { target } = e;
      const matchTagName = tagName => el => el.tagName === tagName;
      const aTag = target.tagName === 'A' ? target : parentWith(matchTagName('A'), target);
      const liTag = target.tagName === 'LI' ? target : parentWith(matchTagName('LI'), target);
      if (aTag) {
        this.switch();
      } else if (liTag) {
        this.labelActive(children(parent(liTag)).indexOf(liTag));
      }
    });
  }

  unbind() {
    this.dropdown.destroy();
  }

  switch() {
    toggleClass(this.instance.classes.DROPDOWNOPEN, this.$dropdown);
  }

  labelActive(index) {
    this.index = index;
    if (this.instance.current.indexOf(index) !== -1) {
      removeClass(this.instance.classes.DROPDOWNOPEN, this.$dropdown);
      return;
    }

    this.instance.toggle(index);

    removeClass(this.instance.classes.ACTIVE, this.$dropdownItems[this.instance.prev[0]]);
    addClass(this.instance.classes.ACTIVE, this.$dropdownItems[index]);
    html(this.$dropdownItems[index].innerHTML, this.$dropdownlabel);
    removeClass(this.instance.classes.DROPDOWNOPEN, this.$dropdown);
  }

  open(index, trigger) {
    this.index = index;

    const $pane = this.instance.$panes[index];

    anime({
      targets: $pane,
      translateY: 0,
      opacity: 1,
      duration: trigger ? this.duration : 1,
      easing: this.effects.in,
      begin: () => {
        addClass(this.instance.classes.ACTIVE, $pane);
      }
    });

    this.resetHeight(!trigger);
  }

  close(index, trigger) {
    const pane = this.instance.$panes[this.instance.prev[0]];
    // console.log(this.instance.prev)
    anime({
      targets: pane,
      translateY: '50%',
      opacity: 0,
      duration: trigger ? this.duration : 1,
      easing: this.effects.out,
      complete: () => compose(setStyle({ transform: 'translateY(-50%)' }), removeClass(this.instance.classes.ACTIVE))(pane)
    });
  }

  resetHeight(immediately = false) {
    if (!this.instance.is('built')) {
      return;
    }

    const innerHeight = outerHeight(this.instance.$contentInners[this.index]);
    if (immediately) {
      setStyle({ height: `${innerHeight}px` }, this.instance.element);
    } else {
      anime({
        targets: this.instance.element,
        height: innerHeight,
        duration: this.duration,
        easing: 'linear'
      });
    }
  }

  resize() {
    const breakWidth = this.instance.options.breakWidth;

    if (breakWidth === false || breakWidth === null) {
      return;
    }

    if (this.$rely.width() > breakWidth) {
      this.toggle(false);
    } else {
      this.resetHeight(true);
      this.toggle(true);
    }
  }
};

var _dec, _dec2, _dec3, _dec4, _dec5, _class;

let Accordion = (_dec = themeable(), _dec2 = styleable(classes), _dec3 = eventable(events), _dec4 = stateable(), _dec5 = register(namespace, {
  defaults: defaults,
  methods: methods,
  dependencies: dependencies
}, info), _dec(_class = _dec2(_class = _dec3(_class = _dec4(_class = _dec5(_class = class Accordion extends Component {
  constructor(element, options = {}) {
    super(namespace, element);

    this.options = deepMerge(defaults, options, this.getDataOptions());

    this.initClasses(classes);
    this.initStates();
    this.initialize();
  }

  initialize() {
    this.initPointer();
    this.processHtml();

    this.ANIMATE = new Animate(this);
    this.RESPONSIVE = new Responsive(this);

    this.bind();
    this.open(this.current, false);

    this.enter('initialized');
    this.trigger(events.READY);
  }

  initPointer() {
    this.$panes = children(this.element);
    this.$headers = this.$panes.map(find(`.${this.classes.PANEHEADER}`));
    this.$contents = this.$panes.map(find(`.${this.classes.PANECONTENT}`));
    this.$contentInners = this.$contents.map(find(`.${this.classes.PANECONTENTINNER}`));

    this.size = this.$panes.length;
    this.isResponsive = this.options.breakWidth === null ? false : Pj.windowWidth <= this.options.breakWidth;

    this.resetData();
  }

  resetData() {
    const $activeItem = this.$panes.map(find(`.${this.classes.ACTIVE}`)).filter(Boolean);
    if ($activeItem.length > 0) {
      this.current = $activeItem.map((_, index) => index);
    } else if (this.options.initialIndex) {
      this.current = this.parseIndex(this.options.initialIndex);
    } else {
      this.current = [0];
    }

    this.prev = this.current;
  }

  processHtml() {
    addClass(this.classes.NAMESPACE, this.element);

    if (this.options.horizontal) {
      addClass(this.classes.HORIZONTAL, this.element);
    }

    if (this.options.theme) {
      addClass(this.getThemeClass(), this.element);
    }
    this.$panes.map(addClass(this.classes.PANE));
    this.$headers.map(addClass(this.classes.PANEHEADER));
    this.$contents.map(addClass(this.classes.PANECONTENT));
    this.$contentInners.map(addClass(this.classes.PANECONTENTINNER));
  }

  parseIndex(index) {
    let arr = [];

    switch (typeof index) {
      case 'string':
        if (index === 'all') {
          for (let i = 0; i < this.size; i++) {
            arr.push(i);
          }
        }
        break;
      case 'number':
        arr.push(index);
        break;
      case 'object':
        if (Array.isArray(index)) {
          arr = index;
        }
        break;
      case 'undefined':
        arr = [0];
        break;
      default:
        break;
    }

    if (!this.options.multiple) {
      arr = [arr[0]];
    }

    return arr;
  }

  bind() {
    this.$panes.map((pane, index) => bindEvent({
      type: this.eventName('click'),
      identity: `.${this.classes.PANEHEADER}`,
      handler: () => {
        if (this.is('disabled')) {
          return false;
        }
        this.toggle(index);
        return false;
      }
    }, pane));
  }

  toggle(index) {
    const pos = this.current.includes(index);
    this.prev = this.current;

    if (!this.options.multiple) {
      this.close(this.prev);
    }

    if (!pos) {
      if (!this.options.multiple || this.is('built') || this.options.horizontal) {
        this.current = [];
      }

      this.current.push(index);
      this.open(index);
    } else {
      this.current.splice(this.current.indexOf(index), 1);
      this.close(index);
    }
  }

  open(index, trigger = true) {
    if (index === null) {
      return;
    }

    const arr = Array.isArray(index) ? index : [index];
    const target = this.is('built') ? this.RESPONSIVE : this.ANIMATE;
    arr.map(index => {
      if (!this.is('built')) {
        addClass(this.classes.ACTIVE, this.$panes[index]);
      }
      return target.open(index, trigger);
    });

    if (this.is('initialized')) {
      this.trigger(events.OPEN, index);
    }
  }

  close(index, trigger = true) {
    if (index === null) {
      return;
    }

    const arr = Array.isArray(index) ? index : [index];
    const target = this.is('built') ? this.RESPONSIVE : this.ANIMATE;
    arr.forEach(index => {
      target.close(index, trigger);

      if (!this.is('built')) {
        removeClass(this.classes.ACTIVE, this.$panes[index]);
      }
    });

    if (this.is('initialized')) {
      this.trigger(events.CLOSE, index);
    }
  }

  resize() {
    this.ANIMATE.resetWidth(true);
    this.RESPONSIVE.resize();
    this.trigger(events.RESIZE);
  }
}) || _class) || _class) || _class) || _class) || _class);

export default Accordion;
