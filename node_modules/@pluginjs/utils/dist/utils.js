(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global['@pluginjs/utils'] = {})));
}(this, (function (exports) { 'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  var defineProperty = function (obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  };

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  var objectWithoutProperties = function (obj, keys) {
    var target = {};

    for (var i in obj) {
      if (keys.indexOf(i) >= 0) continue;
      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
      target[i] = obj[i];
    }

    return target;
  };

  var slicedToArray = function () {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();

  var toConsumableArray = function (arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    } else {
      return Array.from(arr);
    }
  };

  function fromPairs(arr) {
    return arr.reduce(function (r, _ref) {
      var _ref2 = slicedToArray(_ref, 2),
          k = _ref2[0],
          v = _ref2[1];

      return _extends({}, r, defineProperty({}, k, v));
    }, {});
  }

  function mergeWith() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var objs = args.slice(0, -1);
    var customizer = args[args.length - 1];
    return Object.entries(args[0]).reduce(function (r, _ref3) {
      var _ref4 = slicedToArray(_ref3, 1),
          k = _ref4[0];

      return _extends({}, r, defineProperty({}, k, objs.map(function (obj) {
        return obj[k];
      }).filter(function (v) {
        return Boolean(v) || v === 0;
      }).reduce(function (r, i) {
        return customizer(r, i);
      })));
    }, {});
  }

  var T = {
    0: 'X',
    1: 'Y',
    2: 'Z'
  };

  function mapTransformToAnime(str) {
    var css3dList = ['translate', 'rotate', 'scale'];
    return css3dList.filter(function (key) {
      var regx = new RegExp(key, 'g');
      if (str.match(regx)) {
        return true;
      }
      return false;
    }).reduce(function (initialState, key) {
      var matrix = str.match(/\(([^()]+)\)/)[1].split(',');
      var map = mapMatch(key);
      return map(matrix);
    }, {});
  }

  function mapMatch(type) {
    switch (type) {
      case 'translate':
        return mapToTranslate;
      case 'rotate':
        return mapToRotate;
      case 'scale':
        return mapToScale;
      default:
        return function () {
          return 'no match!';
        };
    }
  }

  function mapToScale(matrix) {
    // console.group('scale')
    var result = matrix.map(function (value, index) {
      var n = parseFloat(value, 10);
      var result = defineProperty({}, 'scale' + T[index], n || 0);
      // console.log(result)
      return result;
    });
    return result.reduce(mergeObject);
  }

  function mapToTranslate(matrix) {
    var result = matrix.map(function (value, index) {
      var n = parseFloat(value.slice(0, -2), 10);
      var result = defineProperty({}, 'translate' + T[index], n || 0);
      return result;
    });
    return result.reduce(mergeObject);
  }

  function mapToRotate(matrix) {
    var value = matrix[matrix.length - 1].slice(0, -3);
    var transformType = matrix.slice(0, -1).map(function (n, index) {
      if (parseInt(n, 10)) {
        return 'rotate' + T[index];
      }
      return n;
    }).filter(isNotEmpty);
    return defineProperty({}, transformType[0], parseFloat(value));
  }

  function mergeObject(r, i) {
    return _extends({}, r, i);
  }

  function customizer(objValue, srcValue) {
    if (Array.isArray(objValue)) {
      return objValue.concat(srcValue);
    }
    return [objValue, srcValue];
  }

  function isNotEmpty(value) {
    if (value) {
      return true;
    }
    return false;
  }

  function filterOffset(obj) {
    var offset = obj.offset,
        result = objectWithoutProperties(obj, ['offset']);

    return result;
  }

  function filterEmptyValues(obj) {
    return fromPairs(Object.entries(obj).filter(function (_ref6) {
      var _ref7 = slicedToArray(_ref6, 2),
          v = _ref7[1];

      var arr = v.filter(function (i) {
        return Boolean(i);
      });
      if (arr.length) {
        return true;
      }
      return false;
    }).map(function (_ref8) {
      var _ref9 = slicedToArray(_ref8, 2),
          k = _ref9[0],
          v = _ref9[1];

      var value = v.map(function (i) {
        if (i === undefined) {
          if (/scale/g.test(k)) {
            return 1;
          }
          return 0;
        }
        return i;
      });
      return [k, value];
    }));
  }

  function mapKeyFramesToAnime(keyframes) {
    var transformNoneIndex = [];
    var transformKeys = new Set();
    var newKeyFrames = keyframes.map(function (keyframe, keyframeIndex) {
      var transform = keyframe.transform,
          newKeyFrame = objectWithoutProperties(keyframe, ['transform']);

      if (transform) {
        var arr = transform.split(') ').map(function (item, index, arr) {
          if (index !== arr.length - 1) {
            return item + ')';
          }
          return item;
        }).map(function (value) {
          if (/3d/g.test(value)) {
            var transformObject = mapTransformToAnime(value);
            Object.keys(transformObject).map(function (key) {
              return transformKeys.add(key);
            });
            return transformObject;
          }
          return value;
        }).filter(function (value) {
          return typeof value !== 'string';
        });
        // console.log(arr)
        if (!arr.length) {
          transformNoneIndex.push(keyframeIndex);
          return newKeyFrame;
        }
        return Object.assign.apply(Object, [{}, newKeyFrame].concat(toConsumableArray(arr)));
      }
      return newKeyFrame;
    });
    var emptyTransform = fromPairs(Array.from(transformKeys).map(function (key) {
      if (/scale/g.test(key)) {
        return [key, 1];
      }
      return [key, 0];
    }));
    if (transformNoneIndex.length) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = transformNoneIndex[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var index = _step.value;

          Object.assign(newKeyFrames[index], emptyTransform);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
    var data = mergeWith.apply(undefined, toConsumableArray(newKeyFrames).concat([customizer]));
    var result = filterOffset(filterEmptyValues(data));
    return result;
  }

  var deepClone = function deepClone(obj) {
    if (typeof obj === 'function') {
      return obj;
    }
    return JSON.parse(JSON.stringify(obj));
  };
  function nub(arr) {
    return Array.from(new Set(arr));
  }
  function isPlainObject(data) {
    if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object') {
      return false;
    }

    if (data === null) {
      return false;
    }

    if (data instanceof Set || data instanceof Map) {
      return false;
    }

    if (Array.isArray(data)) {
      return false;
    }

    return true;
  }
  function deepMergeTwo(x, y) {
    if (isPlainObject(y) && isPlainObject(x) || isPlainObject(x) && Array.isArray(y)) {
      return fromPairs$1(nub(Object.keys(x).concat(Object.keys(y))).map(function (key) {
        return [key, deepMergeTwo(x[key], y[key])];
      }));
    }

    if (isPlainObject(y) && typeof x === 'function') {
      return Object.assign(function () {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return x.apply(this, args);
      }, y);
    }

    if (isPlainObject(y) && Array.isArray(x)) {
      return Object.assign([], x, y);
    }

    if (isPlainObject(x) && typeof y === 'function') {
      return Object.assign(function () {
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return y.apply(this, args);
      }, x);
    }

    if (Array.isArray(y) && Array.isArray(x)) {
      // return x.concat(y)
      return nub(Object.keys(y).concat(Object.keys(x))).map(function (index) {
        return deepMergeTwo(x[index], y[index]);
      });
    }

    if (typeof y === 'undefined') {
      return x;
    }
    return y;
  }
  function isObject(obj) {
    return Object(obj) === obj;
  }
  function deepMerge() {
    for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    return args.filter(isObject).reduce(deepMergeTwo);
  }

  var curry = function curry(fn) {
    var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    return function () {
      for (var _len4 = arguments.length, subArgs = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        subArgs[_key4] = arguments[_key4];
      }

      var currylen = fn.currylen || fn.length;
      var collect = args.concat(subArgs);
      if (collect.length >= currylen) {
        return fn.apply(undefined, toConsumableArray(collect));
      }
      return curry(fn, collect);
    };
  };

  var compose = function compose() {
    for (var _len5 = arguments.length, fn = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      fn[_key5] = arguments[_key5];
    }

    var callback = function callback() {
      for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }

      return fn.reduceRight(function (r, i, index) {
        if (Array.isArray(r) && index === fn.length - 1) {
          return i.apply(undefined, toConsumableArray(r));
        }
        return i(r);
      }, args);
    };
    callback.currylen = fn[fn.curylen || fn.length - 1].length;
    return callback;
  };

  var MAX_UID = 1000000;

  function getUID(prefix) {
    do {
      // eslint-disable-next-line no-bitwise
      prefix += ~~(Math.random() * MAX_UID); // "~~" acts like a faster Math.floor() here
    } while (document.getElementById(prefix));
    return prefix;
  }

  function range(v) {
    return Array.from({ length: v }, function (v, i) {
      return i;
    });
  }

  function reflow(element) {
    return element.offsetHeight;
  }

  function arraysEqual(a, b) {
    if (a === b) {
      return true;
    }
    if (a === undefined || b === undefined) {
      return false;
    }
    if (a.length !== b.length) {
      return false;
    }

    for (var i = 0; i < a.length; ++i) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }

  function arrayDiff(a, b) {
    // let t;
    // if (a.length < b.length) {
    //   t = b;
    //   b = a;
    //   a = t;
    // }
    return a.filter(function (n) {
      return b.indexOf(n) < 0;
    });
  }

  function arrayIntersect(a, b) {
    var t = void 0;
    if (b.length > a.length) {
      t = b;
      b = a;
      a = t;
    }
    return a.filter(function (n) {
      return b.indexOf(n) !== -1;
    });
  }

  function convertPercentageToFloat(n) {
    return parseFloat(n.slice(0, -1) / 100, 10);
  }

  function convertFloatToPercentage(n) {
    if (n < 0) {
      n = 0;
    } else if (n > 1) {
      n = 1;
    }
    return parseFloat(n).toFixed(4) * 100 + '%';
  }

  function convertMatrixToArray(value) {
    if (value && value.substr(0, 6) === 'matrix') {
      return value.replace(/^.*\((.*)\)$/g, '$1').replace(/px/g, '').split(/, +/);
    }
    return false;
  }

  function getTime() {
    if (typeof window.performance !== 'undefined' && window.performance.now) {
      return window.performance.now();
    }
    return Date.now();
  }

  function camelize(word) {
    var first = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    word = word.replace(/[_.-\s](\w|$)/g, function (_, x) {
      return x.toUpperCase();
    });

    if (first) {
      word = word.substring(0, 1).toUpperCase() + word.substring(1);
    }
    return word;
  }

  /* Credit to https://github.com/jonschlinkert/get-value MIT */
  function getValueByPath(obj, path) {
    if (Object(obj) !== obj || typeof path === 'undefined') {
      return obj;
    }

    if (path in obj) {
      return obj[path];
    }

    var segs = path.split('.');
    var length = segs.length;
    if (!length) {
      return undefined;
    }
    var i = -1;

    while (obj && ++i < length) {
      var key = segs[i];
      while (key[key.length - 1] === '\\') {
        key = key.slice(0, -1) + '.' + segs[++i];
      }
      obj = obj[key];
    }
    return obj;
  }

  /* Throttle execution of a function.
   * Especially useful for rate limiting execution of
   * handlers on events like resize and scroll. */
  function throttle(func, delay) {
    var _this = this;

    var running = false;
    function resetRunning() {
      running = false;
    }

    if (delay !== undefined || delay !== null) {
      return function () {
        for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
          args[_key7] = arguments[_key7];
        }

        var that = _this;

        if (running) {
          return;
        }
        running = true;
        func.apply(that, args);
        window.setTimeout(resetRunning, delay);
      };
    }

    return function () {
      for (var _len8 = arguments.length, args = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        args[_key8] = arguments[_key8];
      }

      var that = _this;

      if (running) {
        return;
      }
      running = true;
      window.requestAnimationFrame(function () {
        func.apply(that, args);
        resetRunning();
      });
    };
  }

  /* Debounce execution of a function.
   * Debouncing, unlike throttling, guarantees that a function
   * is only executed a single time at the very end. */
  function debounce(func) {
    var _this2 = this;

    var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;

    var timer = void 0;

    return function () {
      for (var _len9 = arguments.length, args = Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        args[_key9] = arguments[_key9];
      }

      var that = _this2;
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      timer = setTimeout(function () {
        func.apply(that, args);
      }, delay);
    };
  }

  function fromPairs$1(arr) {
    return arr.reduce(function (r, _ref) {
      var _ref2 = slicedToArray(_ref, 2),
          k = _ref2[0],
          v = _ref2[1];

      return _extends({}, r, defineProperty({}, k, v));
    }, {});
  }
  function mergeWith$1(obj1, obj2, customizer) {
    return Object.entries(obj1).reduce(function (r, _ref3) {
      var _ref4 = slicedToArray(_ref3, 2),
          k = _ref4[0],
          v = _ref4[1];

      return _extends({}, r, defineProperty({}, k, customizer(v, obj2[k])));
    }, {});
  }

  exports.deepClone = deepClone;
  exports.nub = nub;
  exports.isPlainObject = isPlainObject;
  exports.deepMerge = deepMerge;
  exports.curry = curry;
  exports.compose = compose;
  exports.getUID = getUID;
  exports.range = range;
  exports.reflow = reflow;
  exports.arraysEqual = arraysEqual;
  exports.arrayDiff = arrayDiff;
  exports.arrayIntersect = arrayIntersect;
  exports.convertPercentageToFloat = convertPercentageToFloat;
  exports.convertFloatToPercentage = convertFloatToPercentage;
  exports.convertMatrixToArray = convertMatrixToArray;
  exports.getTime = getTime;
  exports.camelize = camelize;
  exports.getValueByPath = getValueByPath;
  exports.throttle = throttle;
  exports.debounce = debounce;
  exports.fromPairs = fromPairs$1;
  exports.mergeWith = mergeWith$1;
  exports.keyframes2Anime = mapKeyFramesToAnime;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
